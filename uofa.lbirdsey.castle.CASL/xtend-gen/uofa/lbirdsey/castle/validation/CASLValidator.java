/**
 * generated by Xtext
 */
package uofa.lbirdsey.castle.validation;

import com.google.common.base.Objects;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ComposedChecks;
import uofa.lbirdsey.castle.casl.Agent;
import uofa.lbirdsey.castle.casl.Behavior;
import uofa.lbirdsey.castle.casl.BehaviorType;
import uofa.lbirdsey.castle.casl.CAS_Semantic_Group_Switch;
import uofa.lbirdsey.castle.casl.CaslPackage;
import uofa.lbirdsey.castle.casl.Entity;
import uofa.lbirdsey.castle.casl.Environment;
import uofa.lbirdsey.castle.casl.FeatureCall;
import uofa.lbirdsey.castle.casl.Field;
import uofa.lbirdsey.castle.casl.Function;
import uofa.lbirdsey.castle.casl.Group;
import uofa.lbirdsey.castle.casl.Interaction;
import uofa.lbirdsey.castle.casl.InteractionFeatureCall;
import uofa.lbirdsey.castle.generator.semanticGroups.helpers.Constants;
import uofa.lbirdsey.castle.generator.semanticGroups.helpers.HelperFunctions;
import uofa.lbirdsey.castle.validation.AbstractCASLValidator;
import uofa.lbirdsey.castle.validation.AgentValidator;
import uofa.lbirdsey.castle.validation.EnvironmentValidator;
import uofa.lbirdsey.castle.validation.GroupValidator;
import uofa.lbirdsey.castle.validation.SystemValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators = { AgentValidator.class, GroupValidator.class, EnvironmentValidator.class, SystemValidator.class })
@SuppressWarnings("all")
public class CASLValidator extends AbstractCASLValidator {
  /**
   * Global Checks
   */
  @Check
  public void checkEntityNameStartsWithCapital(final Entity ent) {
    boolean _isUpperCase = Character.isUpperCase(ent.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      CaslPackage.eINSTANCE.getSystem_Cas_rules();
      String _name = ent.getName();
      String _plus = (_name + " name should begin with a capital letter");
      this.warning(_plus, CaslPackage.eINSTANCE.getEntity_Name());
    }
  }
  
  @Check
  public Object checkGroupIsDefined(final Entity ent, final uofa.lbirdsey.castle.casl.System sys) {
    Object _xblockexpression = null;
    {
      CAS_Semantic_Group_Switch _semanticgroups = sys.getCas_rules().getSemanticgroups();
      boolean sgActive = Objects.equal(_semanticgroups, CAS_Semantic_Group_Switch.ENABLE);
      Object _xifexpression = null;
      if (sgActive) {
        _xifexpression = null;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Function Checking
   */
  @Check
  public void checkInitializeFunctionExists(final Entity ent) {
    boolean exists = false;
    List<Function> functionList = null;
    String entClass = ent.getName();
    if ((ent instanceof Agent)) {
      Agent agt = ((Agent) ent);
      functionList = agt.getAgent_functions().getFunctions();
    } else {
      if ((ent instanceof Environment)) {
        Environment env = ((Environment) ent);
        functionList = env.getEnv_functions().getFunctions();
      } else {
        if ((ent instanceof Group)) {
          Group grp = ((Group) ent);
          functionList = grp.getGroup_functions().getFunctions();
        }
      }
    }
    for (final Function f : functionList) {
      {
        Function fn = ((Function) f);
        String _name = fn.getName();
        int _compareToIgnoreCase = ((String) _name).compareToIgnoreCase("initialize");
        boolean _equals = (_compareToIgnoreCase == 0);
        if (_equals) {
          exists = true;
        }
      }
    }
    if ((!exists)) {
      this.error((entClass + " does not contain an initialize function"), CaslPackage.eINSTANCE.getEntity_Name());
    }
  }
  
  @Check
  public void checkBehavior(final Behavior behavior) {
    Behavior fn = behavior;
    EList<EObject> behaviorBody = fn.getBody();
    for (final EObject bb : behaviorBody) {
      if ((bb instanceof FeatureCall)) {
        EObject beh = ((FeatureCall)bb).getFc();
        if (((beh instanceof InteractionFeatureCall) && Objects.equal(fn.getBehavior_type(), BehaviorType.SELF))) {
          String _name = fn.getName();
          String _plus = (_name + " contains an Interaction but Behavior Type is set to SELF. Change to AFFECT or remove Interaction");
          this.error(_plus, CaslPackage.eINSTANCE.getBehavior_Name());
        } else {
          if (((!(beh instanceof InteractionFeatureCall)) && (!Objects.equal(fn.getBehavior_type(), BehaviorType.SELF)))) {
            String _name_1 = fn.getName();
            String _plus_1 = (_name_1 + " is set to AFFECT but has no Interaction.");
            this.error(_plus_1, CaslPackage.eINSTANCE.getBehavior_Name());
          }
        }
      }
    }
  }
  
  @Check
  public void checkInteractions(final Interaction inter) {
    final EList<EObject> interBody = inter.getBody();
    for (final EObject ib : interBody) {
    }
  }
  
  @Check
  public void checkForLayoutParameterVariable(final Entity ent) {
    List<EObject> fields = null;
    if ((ent instanceof Environment)) {
      Environment env = ((Environment) ent);
      fields = env.getEnv_parameters().getFields();
    } else {
      if ((ent instanceof Group)) {
        Group grp = ((Group) ent);
        fields = grp.getGroup_parameters().getFields();
      }
    }
    boolean lpPresent = false;
    for (final EObject f : fields) {
      if ((f instanceof Field)) {
        Field fi = ((Field) f);
        boolean _equalsIgnoreCase = HelperFunctions.getFieldName(((Field) fi)).equalsIgnoreCase(Constants.LAYOUT_PARAMETERS_NAME);
        if (_equalsIgnoreCase) {
          lpPresent = true;
        }
      }
    }
    if ((!lpPresent)) {
      String _name = ent.getName();
      String _plus = (_name + " does not have ");
      String _plus_1 = (_plus + Constants.LAYOUT_PARAMETERS_NAME);
      String _plus_2 = (_plus_1 + " defined in its parameters. ");
      this.error(_plus_2, CaslPackage.eINSTANCE.getEntity_Name());
    }
  }
}
