/*
 * generated by Xtext
 */
package uofa.lbirdsey.castle.generator.repast

import com.google.inject.Inject
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.EObject

import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider

import uofa.lbirdsey.castle.casl.AdaptationDelay
import uofa.lbirdsey.castle.casl.AdaptiveProcessFeatureCall
import uofa.lbirdsey.castle.casl.Agent
import uofa.lbirdsey.castle.casl.Agent_Call
//import uofa.lbirdsey.castle.casl.AndOrExpression
import uofa.lbirdsey.castle.casl.ArithmeticSigned
import uofa.lbirdsey.castle.casl.BehaviorFeatureCall
import uofa.lbirdsey.castle.casl.BooleanNegation
import uofa.lbirdsey.castle.casl.BooleanType
import uofa.lbirdsey.castle.casl.CASL_Macro_Neighbours
import uofa.lbirdsey.castle.casl.CAS_Rule_Exception
import uofa.lbirdsey.castle.casl.Casl
import uofa.lbirdsey.castle.casl.Comparison
import uofa.lbirdsey.castle.casl.DataTypeDeclaration
import uofa.lbirdsey.castle.casl.EndConditionTypes
import uofa.lbirdsey.castle.casl.Environment
import uofa.lbirdsey.castle.casl.Equals
import uofa.lbirdsey.castle.casl.Expression
import uofa.lbirdsey.castle.casl.FeatureCall
import uofa.lbirdsey.castle.casl.Field
import uofa.lbirdsey.castle.casl.Formula
import uofa.lbirdsey.castle.casl.FunctionFeatureCall
import uofa.lbirdsey.castle.casl.FunctionCall
import uofa.lbirdsey.castle.casl.FunctionParameter
import uofa.lbirdsey.castle.casl.IfStatement
import uofa.lbirdsey.castle.casl.InteractionTriggerTypes
import uofa.lbirdsey.castle.casl.MacroCall
//import uofa.lbirdsey.castle.casl.Multi
import uofa.lbirdsey.castle.casl.NumberLiteral
import uofa.lbirdsey.castle.casl.Raw_Java_Block
import uofa.lbirdsey.castle.casl.SelfAssignedFormula
import uofa.lbirdsey.castle.casl.Concern
import uofa.lbirdsey.castle.casl.StringLiteral
import uofa.lbirdsey.castle.casl.Symbol
import uofa.lbirdsey.castle.casl.System
import uofa.lbirdsey.castle.casl.SystemCallObj
import uofa.lbirdsey.castle.casl.Type
import uofa.lbirdsey.castle.casl.TypeRef
import uofa.lbirdsey.castle.casl.WorldType
import uofa.lbirdsey.castle.casl.CASL_Macro_FilterAndFunction
import uofa.lbirdsey.castle.casl.CASL_Macro_CountConditions
import uofa.lbirdsey.castle.casl.BehaviorReactionTime
import uofa.lbirdsey.castle.casl.AgentInteractionFeatureCall
import uofa.lbirdsey.castle.casl.EnvironmentInteractionFeatureCall
import uofa.lbirdsey.castle.casl.FeatureCallExp
import uofa.lbirdsey.castle.casl.Interaction
import uofa.lbirdsey.castle.casl.InteractionFeatureCall
import uofa.lbirdsey.castle.casl.CASL_Macro_Random
import uofa.lbirdsey.castle.casl.numType
import uofa.lbirdsey.castle.casl.Addition
import uofa.lbirdsey.castle.casl.Subtraction
import uofa.lbirdsey.castle.casl.SelfCallExpr
import uofa.lbirdsey.castle.casl.CASL_Macro_ForEach
import uofa.lbirdsey.castle.casl.Environment_Call
import uofa.lbirdsey.castle.casl.AbstractElement
import uofa.lbirdsey.castle.casl.PackageDeclaration
import uofa.lbirdsey.castle.casl.Import
import uofa.lbirdsey.castle.casl.PrimitiveType
import uofa.lbirdsey.castle.casl.StringType
import uofa.lbirdsey.castle.casl.Function
import uofa.lbirdsey.castle.casl.NullTypeLiteral
//import uofa.lbirdsey.castle.casl.NotEqual
import uofa.lbirdsey.castle.casl.CASL_Macro_Print
import uofa.lbirdsey.castle.casl.EnvironmentFieldReference
import uofa.lbirdsey.castle.casl.AgentFieldReference
import uofa.lbirdsey.castle.casl.FunctionCallExpr
import uofa.lbirdsey.castle.casl.SelfCall
import uofa.lbirdsey.castle.casl.EnumCallExpr
import uofa.lbirdsey.castle.casl.Group

/**
 * Generates code from your model files on save. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RepastGenerator_OLDCASL implements IGenerator {	
	
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		//Create sub-directories for each CAS Type
		var dirName = "";
	 		 
		//Process the SYSTEM
		for(sys : resource.allContents.toIterable.filter(System)) {
			dirName = sys.name;
			fsa.generateFile(
				dirName+"/"+sys.fullyQualifiedName.toString("/").replaceAll(" ","") + ".java", sys.compileSystem.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
		}
		
		//Generate the classes and get them imported!
	 	for (ae : resource.allContents.toIterable.filter(AbstractElement)){
	 		if (ae instanceof uofa.lbirdsey.castle.casl.Object){
	 			var pkgs = ae as uofa.lbirdsey.castle.casl.Object
		 		fsa.generateFile(
		 			dirName+"/objects/"+pkgs.name+".java", pkgs.createPackages.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
 			} else if (ae instanceof uofa.lbirdsey.castle.casl.Enum){
 				var pkgs = ae as uofa.lbirdsey.castle.casl.Enum
 				//Generate all ENUMS then place into a single file
 				fsa.generateFile(
		 			dirName+"/objects/"+pkgs.name+"_ENUM.java", pkgs.createPackages.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
 			}
	 	}
		//Process the AGENTs
		for(e : resource.allContents.toIterable.filter(Agent)) {
			fsa.generateFile(
				dirName+"/agents/"+e.fullyQualifiedName.toString("/") + ".java", e.compileAgent.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
		}
		
		//Process the GROUPS
		for(e : resource.allContents.toIterable.filter(Group)) {
			fsa.generateFile(
				dirName+"/groups/"+e.fullyQualifiedName.toString("/") + ".java", e.compileGroup.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
		}
		
		//Process the ENVIRONMENTS
		for(e : resource.allContents.toIterable.filter(Environment)) {
			fsa.generateFile(
				dirName+"/environments/"+e.fullyQualifiedName.toString("/") + ".java", e.compileEnvironment.toString.replaceAll("string","String").replaceAll("bool","boolean").replaceAll("(;)+",";"))
		}		
	} 
	
	def compileSystem(System sys)'''
		«generateSystemBuilder()»
		
		public class «sys.name.replaceAll(" ","")» implements ContextBuilder<Agent> {
			String name = "«sys.name»";
			String description = "«sys.desc.replaceAll("\n","\"\n\t + \"")»";
			
			/*****Ruleset*****/
			
			//Type
			CAS_Rule_Type ruleType = CAS_Rule_Type.«sys.cas_rules.cas_rule.toString.toUpperCase»;
			
			//Checking
			CAS_Inspection_Level ruleCheckType = CAS_Inspection_Level.«sys.cas_rules.cas_check.toString.toUpperCase»;
			
			//Exceptions
			CAS_Rule_Exception ruleExceptions[] = new CAS_Rule_Exception[]{«printRuleExceptionArgs(sys.cas_rules.exceptions)»};
			 
			CASRuleSet ruleSet = new CASRuleSet(ruleCheckType, ruleType, ruleExceptions);
			
			/*****Agent Types*****/ //is there much point in printing this?
			«FOR a: sys.agent_types.agent_types»
			Agent «a.agent_type_name»;
			ArrayList<«a.agent_type_name»> «a.agent_type_name»List;
			«ENDFOR»
			
			/*****Environment Types Present*****/
			«FOR env: sys.environment_types.environment_types»
			Environment «env.environment_type_name»;
			ArrayList<«env.environment_type_name»> «env.environment_type_name»List;
			«ENDFOR»
			
			/*****System Parameters*****/
			«sys.generateParameters()»
			
			/*****System Functions*****/
			«sys.generateFunctions()»
			
			/*****Termination Conditions*****/
			«sys.generateEndConditions()»
			
			/*****CAS Checking*****/
			«sys.generateCASChecker()»
			
			«sys.generateDebugFunctions()»
			
			/*****Repast Stuff*****/
			«sys.repastBuildInitialiser()»
		}
	'''
	
	//This should really be subclass stuff in the System class
	def compilePackage(Casl casl)'''
	«FOR pkg : casl.packageElements»
		«IF pkg instanceof Type»
		«ENDIF»
	«ENDFOR»
	'''
	
	//Parse an AGENTs stuff and break it down
	def compileAgent(Agent a) '''
		«IF a.eContainer.fullyQualifiedName != null»
			package «a.eContainer.fullyQualifiedName»;
		«ENDIF»
		«generateAgentBuilder()»
		
		public class «a.name» extends Agent {
			/*Description: «a.desc»*/
			
			/*****«a.name.toFirstUpper» Initialisation*****/
			«a.agentInitialisation()»
			
			/*****«a.name.toFirstUpper» Parameters*****/
			«a.generateParameters()»
			
			/*****«a.name.toFirstUpper» Functions*****/
			«a.generateFunctions()»
			
			/*****«a.name.toFirstUpper» Behaviors*****/
			«a.generateBehaviors()»
			
			/*****«a.name.toFirstUpper» Interactions*****/
			«a.generateInteractions()»
			
			/*****«a.name.toFirstUpper» Adaptation*****/
			«a.generateAdaptations()»
				
			/*****«a.name.toFirstUpper» Subsystems*****/
			«a.generateSubsystems()»
			
			/*****Repast Functions*****/
			«a.miscRepast()»
			
			/*****Pre-defined Schedules - pre() and post()*****/
			«a.createPre()»
			«a.createPost()»
			
			/*****Schedule Initialisation*****/
			«print(a.scheduleInit)»
			
		}
	'''
	
		//Parse a GROUPs stuff and break it down
	def compileGroup(Group g) '''
		«IF g.eContainer.fullyQualifiedName != null»
			package «g.eContainer.fullyQualifiedName»;
		«ENDIF»
		«generateAgentBuilder()»
		
		public class «g.name» extends Agent {
			/*Description: «g.desc»*/
			
			/*****«g.name.toFirstUpper» Initialisation*****/
			«groupInitialisation(g)»
			
			/*****«g.name.toFirstUpper» Parameters*****/
			«generateParameters(g)»
			
			/*****«g.name.toFirstUpper» Functions*****/
			«generateFunctions(g)»
			
			/*****«g.name.toFirstUpper» Transmissions*****/
			«generateTransmissions(g)»
			
			/*****«g.name.toFirstUpper» Internals*****/
			«generateInternals(g)»
			
«««			/*****Repast Functions*****/
«««			«g.miscRepast()»
			
			/*****Pre-defined Schedules - pre() and post()*****/
			«g.createPre()»
			«g.createPost()»
			
			/*****Schedule Initialisation*****/
			«print(g.scheduleInit)»
			
		}
	'''
	def compileEnvironment(Environment env) '''
		«IF env.eContainer.fullyQualifiedName != null»
			package «env.eContainer.fullyQualifiedName»;
		«ENDIF»
		«generateEnvironmentBuilder()»
		public class «env.name» extends Environment {
			/*Description: «env.desc»*/
			
			/*****«env.name.toFirstUpper» Initialisation*****/
			«env.EnvironmentInitialisation()»
			
			
			«env.generateParameters()»
			/*****«env.name.toFirstUpper» Functions*****/
			«env.generateFunctions()»
			
			/*****«env.name.toFirstUpper» Behaviors*****/
			«env.generateBehaviors()»
			
			/*****«env.name.toFirstUpper» Interactions*****/
			«env.generateInteractions()»
			
			/*****«env.name.toFirstUpper» Adaptation*****/
			«env.generateAdaptations()»
				
			/*****«env.name.toFirstUpper» Subsystems*****/
			«env.generateSubsystems()»
			
			/*****«env.name.toFirstUpper» Group Interactions*****/			
			«generateGroupInteractions(env)»
			
			/*****Repast Functions*****/
			«env.miscRepast()»
			
			/*****Pre-defined Schedules - pre() and post()*****/
			«env.createPre()»
			«env.createPost()»
			
			/*****Schedule Initialisation*****/
			«print(env.scheduleInit)»
		}		
	'''
	
	def generateGroupInteractions(Environment environment) {
		
	}
	

	
	def String createPackages(AbstractElement e){
		var output = "";
		if (e instanceof PackageDeclaration){
			output = (e as PackageDeclaration).name
		} else if (e instanceof Type){
			var typ = e as Type
			if (typ instanceof PrimitiveType){
				
			} else if (typ instanceof uofa.lbirdsey.castle.casl.Object) {
				var obj = typ as uofa.lbirdsey.castle.casl.Object
				output += "public class "+obj.name +" extends CASObject {\n"
				output += "\tpublic " + obj.name+"() {\n"
				output +="\t\tsuper(\""+obj.name+"\");\n"
				output += "\t}\n"
				for (field : obj.fields){
					if (field instanceof Field){
						output += "\t"+printFieldDeclarations(field)+";\n"
						output += "\t"+generateGettersSetters(field) +"\n"
					} else if (field instanceof Function){
						val func = field as Function
						output  += "\t"
						if (func.returnType != null) {
							output += (func.returnType as FunctionParameter).type.name
						} else {
							output += "void"
						}
						output += " "+func.name+"("+printFunctionParameters(func.functionParameters)+") {\n"
						for (statement : func.body){
							output += "\t\t"+parseBodyElement(statement)+"\n"
						}
						if (func.returnType != null) {
							output += "return " + func.returnType.name + "\n"
						} 
						output += "\t}\n"
					}
				}
				output += "\n}"
			} else if (typ instanceof uofa.lbirdsey.castle.casl.Enum){
				//TODO: How do we handle Enums?
				var obj = typ as uofa.lbirdsey.castle.casl.Enum
				output += "public class "+obj.name +"_ENUM {\n"
				output += "\tpublic " + obj.name+"_ENUM() {\n"
				output += "\t}\n"
				output += "\tpublic enum "+obj.name +"{\n"
				output += "\t\t"
				for (fi : obj.enum_fields) {
					output += fi.name+","
				}
				
				output = output.substring(0,output.length-1)
				output += "\n\t}"
				output += "\n}"
			}
		} else if (e instanceof Import){
			
		}
		return output
	}
	
//*********AGENT GENERATION********//

	def agentInitialisation(Agent a)'''
	ArrayList<Function<«a.name»,Void>> postQueue;
	
	public «a.name»(ContinuousSpace<Agent> space, Grid<Agent> grid, String «a.name.toFirstLower»ID, Vector2 initialPosition){
		super(«a.name.toFirstLower»ID, initialPosition);
		assignSpace(grid,space);
		super.setType("«a.name.toFirstUpper»");
		super.agentsColor = getAgentsColor();
		postQueue = new ArrayList<Function<«a.name»,Void>>();
	}'''
	
	def EnvironmentInitialisation(Environment env)'''
	ArrayList<Function<«env.name»,Void>> postQueue;
	
	public «env.name»(ContinuousSpace<Environment> space, Grid<Environment> grid, String «env.name.toFirstLower»ID, Vector2 initialPosition){
		super(«env.name.toFirstLower»ID, initialPosition);
		assignSpace(grid,space);
		super.setType("«env.name.toFirstUpper»");
		super.agentsColor = getAgentsColor();
		postQueue = new ArrayList<Function<«env.name»,Void>>();
	}'''
	
	def groupInitialisation(Group grp)'''
	ArrayList<Function<«grp.name»,Void>> postQueue;
	
	public «grp.name»(ContinuousSpace<Environment> space, Grid<Environment> grid, String «grp.name.toFirstLower»ID, Vector2 initialPosition){
		super(«grp.name.toFirstLower»ID, initialPosition);
		assignSpace(grid,space);
		super.setType("«grp.name.toFirstUpper»");
		super.agentsColor = getAgentsColor();
		postQueue = new ArrayList<Function<«grp.name»,Void>>();
	}'''
	
	def generateFunctions(Agent a) '''
		«FOR function : a.agent_functions.functions»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		public «IF function.returnType != null»«inferSymbolType((function.returnType as FunctionParameter))»«ELSE»void«ENDIF» «function.name»(«print(printFunctionParameters(function.functionParameters))») {
			«IF function.returnType != null»«inferSymbolType((function.returnType as FunctionParameter))» «function.returnType.name»;«ENDIF»
			«IF function.name == "init"»
				«FOR sb : a.agent_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					registerState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
			«ENDIF»
			«FOR statement : function.body»
				«parseBodyElement(statement)»
			«ENDFOR»
			«IF function.returnType != null»return «function.returnType.name»;«ENDIF»
		}
		«ENDFOR»'''
	
		def generateParameters(Agent a) '''
		//Fields
		«FOR field : a.agent_parameters.fields»
		«IF (field instanceof Field)»
			private «printFieldDeclarations(field as Field)»;
		«ELSEIF (field instanceof Concern)»
		«ENDIF»
		«ENDFOR»
		//Repast specific fields
		private Grid<Agent> grid;
		private ContinuousSpace<Agent> space;
		
		//Getters & Setters
		«FOR field : a.agent_parameters.fields»
			«IF (field instanceof Field)»
				«generateGettersSetters(field as Field)»
			«ENDIF»
		«ENDFOR»
		//Repast specific getters/setters
		public Grid<Agent> getGrid() {
			return grid;
		}
		public void setGrid(Grid<Agent> grid) {
			this.grid = grid;
		}
		public ContinuousSpace<Agent> getSpace() {
			return space;
		}
		public void setSpace(ContinuousSpace<Agent> space) {
			this.space = space;
		}
	'''

	def generateGettersSetters(Field field){ 
		var output = "";
		if (field.declaration != null){
			var fiedecl = field.declaration as DataTypeDeclaration;
			output += "public void set"+fiedecl.name.toFirstUpper+"("
			if (fiedecl.type != null){
				output += fiedecl.type.name
			} else if (fiedecl.obj != null){
				if (fiedecl.obj instanceof uofa.lbirdsey.castle.casl.Object)
					output += fiedecl.obj.name
				else if (fiedecl.obj instanceof uofa.lbirdsey.castle.casl.Enum)
					output += fiedecl.obj.name+"_ENUM."+fiedecl.obj.name
			}
			output += " "+fiedecl.name+") {\n\tthis."+fiedecl.name +" = "+fiedecl.name+";\n}\n"
			output += "public "
			if (fiedecl.type != null) {
				output += fiedecl.type.name
			} else if (fiedecl.obj != null){
				if (fiedecl.obj instanceof uofa.lbirdsey.castle.casl.Object)
					output += fiedecl.obj.name
				else if (fiedecl.obj instanceof uofa.lbirdsey.castle.casl.Enum)
					output += fiedecl.obj.name+"_ENUM."+fiedecl.obj.name
			} 
			output += " get"+fiedecl.name.toFirstUpper+"() {\n\treturn this."+fiedecl.name+";\n}\n"			
					
		} else if (field.agentFieldRef != null){
			var fieagent = field.agentFieldRef as AgentFieldReference
			output += "public void set"+fieagent.name.toFirstUpper+"("+fieagent.agent.name+" "+fieagent.name+") {\n\t\tthis."+fieagent.name+" = "+fieagent.name+";\n}\n"
			output += "public "+fieagent.agent.name+" get"+fieagent.name.toFirstUpper+"(){\n\treturn this."+fieagent.name+";\n}\n"
		} else if (field.envFieldRef != null){
			var fieenv = field.envFieldRef as EnvironmentFieldReference
			output += "public void set"+fieenv.name.toFirstUpper+"("+fieenv.env.name+" "+fieenv.name+") {\n\t\tthis."+fieenv.name+" = "+fieenv.name+";\n}\n"
			output += "public "+fieenv.env.name+" get"+fieenv.name.toFirstUpper+"(){\n\treturn this."+fieenv.name+";\n}\n"
			
		}
		return output;
	}
		   
	def generateBehaviors(Agent a) {'''
		«FOR behavior : a.agent_behaviors.behaviors»
		private void «behavior.name»(«print(printFunctionParameters(behavior.functionParameters))») {
			«FOR statement : behavior.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''}
	
	def generateInteractions(Agent a) {
			var output = "";
			for (interaction : a.agent_interactions.interactions) {
				output += parseInteraction(interaction)+"\n"
			}
			return output	
	}
	
	def parseInteraction(Interaction interaction){
		var output = "public ";
		output += inferInteractionType(interaction)+" " +interaction.name+ "(" + printFunctionParameters(interaction.functionParameters) +")"
		output += " {\n"
		for (statement : interaction.body){
			output += "\t" + parseBodyElement(statement) +"\n"
		}
		output += "\t"+returnInteractionVar(interaction)
		output += "\n}"
		
		return output		
	}
	
	//There's clearly a better way to do this
	def inferInteractionType(Interaction inter){
		val body = inter.body
		val finalTerm = body.reverseView.head
		var output = "";
		if (finalTerm instanceof Field) {
			val ftf = finalTerm as Field
			if (ftf.declaration != null){
				output = inferTypeFromDeclaration(ftf.declaration as DataTypeDeclaration);
			} else if (ftf.agentFieldRef != null){
				output = (ftf.agentFieldRef as AgentFieldReference).agent.name
			} else if (ftf.envFieldRef != null){
				output = (ftf.envFieldRef as EnvironmentFieldReference).env.name
			}
		} else if (finalTerm instanceof Formula) {
			val ftf = finalTerm as Formula
			if (ftf.sym instanceof AgentFieldReference){
				output = (ftf.sym as AgentFieldReference).agent.name;
			} else if (ftf.sym instanceof EnvironmentFieldReference){
				output = (ftf.sym as EnvironmentFieldReference).env.name;
			} else if (ftf.sym instanceof DataTypeDeclaration){
				var dtd = ftf.sym as DataTypeDeclaration
				if (dtd.type != null) {		
					output = dtd.type.name
				} else if (dtd.obj != null){
					output = dtd.obj.name;
				}
			} else if (ftf.sym instanceof FunctionParameter){
				var fp = ftf.sym as FunctionParameter
				if (fp.type != null) {		
					output = fp.type.name
				} else if (fp.obj != null){
					output = fp.obj.name;
				}
			}

		} else if (finalTerm instanceof SelfAssignedFormula) {
			val ftf = finalTerm as SelfAssignedFormula
			if (ftf.ref instanceof AgentFieldReference){
				output = (ftf.ref as AgentFieldReference).agent.name;
			} else if (ftf.ref instanceof EnvironmentFieldReference){
				output = (ftf.ref as EnvironmentFieldReference).env.name;
			} else if (ftf.ref instanceof DataTypeDeclaration){
				var dtd = ftf.ref as DataTypeDeclaration
				if (dtd.type != null) {		
					output = dtd.type.name
				} else if (dtd.obj != null){
					output = dtd.obj.name;
				}
			} else if (ftf.ref instanceof FunctionParameter){
				var fp = ftf.ref as FunctionParameter
				if (fp.type != null) {		
					output = fp.type.name
				} else if (fp.obj != null){
					output = fp.obj.name;
				}
			}
		} else if (finalTerm instanceof FunctionCall) {
			output = "void"
		} else if (finalTerm instanceof Expression){
			output = inferExpressionType(finalTerm as Expression)
		} else if (finalTerm instanceof uofa.lbirdsey.castle.casl.Enum){
			output = (finalTerm as uofa.lbirdsey.castle.casl.Enum).name+"_ENUM."+(finalTerm as uofa.lbirdsey.castle.casl.Enum).name
		} else if (finalTerm instanceof SelfCall){
			output = "selfcall"
		} else {
			output = "void"
		}
		
		return output;
	} 
	
	def inferTypeFromDeclaration(DataTypeDeclaration dtd){
		var output = "";
		if (dtd.type != null){
			output = dtd.type.name;
		} else if (dtd.obj != null) {
			if (dtd.obj instanceof uofa.lbirdsey.castle.casl.Object) {
				output = (dtd.obj as uofa.lbirdsey.castle.casl.Object).name;
			} else {
				output = (dtd.obj as uofa.lbirdsey.castle.casl.Enum).name+"_ENUM."+(dtd.obj as uofa.lbirdsey.castle.casl.Enum).name;
			}
			if (dtd.useObj != null){
				output = "ERROR:ITFD1"
			} else if (dtd.useType != null){
				output = "ERROR:ITFD2"
			}
		} 
		return output;
	}
	
	def inferFunctionParameterType(FunctionParameter fp){
		var output = "";
		if (fp.type != null){
			output = fp.type.name
		} else if (fp.obj != null){
			if (fp.obj instanceof uofa.lbirdsey.castle.casl.Object) {
				output = (fp.obj as uofa.lbirdsey.castle.casl.Object).name;
			} else {
				output = (fp.obj as uofa.lbirdsey.castle.casl.Enum).name+"_ENUM."+(fp.obj as uofa.lbirdsey.castle.casl.Enum).name;				
			}
			
		} else if (fp.agent != null){
			output = fp.agent.name
		} else if (fp.env != null){
			output = fp.env.name
		}
		
		return output;
	}
	
	def returnInteractionVar(Interaction inter){		
		val body = inter.body
		val finalTerm = body.reverseView.head
		var output = "";
		if (finalTerm instanceof Field) {
			val ftf = finalTerm as Field
			if (ftf.declaration != null){
				output = ftf.declaration.name
			} else if (ftf.agentFieldRef != null){
				output = ftf.agentFieldRef.name
			} else if (ftf.envFieldRef != null){
				output = ftf.envFieldRef.name
			}
		} else if (finalTerm instanceof Formula) {
			val ftf = finalTerm as Formula
			output = ftf.sym.name
		}  else if (finalTerm instanceof SelfAssignedFormula) {
			val ftf = finalTerm as SelfAssignedFormula
			if (ftf.ref instanceof AgentFieldReference){
				output = (ftf.ref as AgentFieldReference).agent.name;
			} else if (ftf.ref instanceof EnvironmentFieldReference){
				output = (ftf.ref as EnvironmentFieldReference).env.name;
			} else if (ftf.ref instanceof DataTypeDeclaration){
				var dtd = ftf.ref as DataTypeDeclaration
				if (dtd.type != null) {		
					output = dtd.type.name+"RIV_ERROR1";
				} else if (dtd.obj != null){
					output = dtd.name;
				}
			} else if (ftf.ref instanceof FunctionParameter){
				var fp = ftf.ref as FunctionParameter
				if (fp.type != null) {		
					output = fp.type.name
				} else if (fp.obj != null){
					output = fp.obj.name;
				}
			}			
		} else if (finalTerm instanceof FunctionCallExpr) {
			output = parseFunctionCall((finalTerm as FunctionCallExpr).funcCall)
		} else if (finalTerm instanceof SelfCallExpr) {
			output = parseSelfCall(finalTerm as SelfCallExpr)
		} else if (finalTerm instanceof uofa.lbirdsey.castle.casl.Enum){
			output = (finalTerm as uofa.lbirdsey.castle.casl.Enum).name+"_ENUM."+(finalTerm as uofa.lbirdsey.castle.casl.Enum).name
		} 
		if (output.length > 0){
			output = "return " + output+";"
		}
		return output;
	}
	
	def inferExpressionType(Expression expr){
		var output = ""
		if (expr instanceof Expression){ //is this needed, feels redundant
			if (expr instanceof SelfCallExpr){
				output = "selfcall"
				var sce = (expr as SelfCallExpr).selfCall;
				if (sce.ref != null){
					output = inferSymbolType(sce.ref) //????
				} else if (sce.fc != null){
					output = "functioncall inferral"
				} else if (sce.fec != null) {
					if (sce.fec instanceof InteractionFeatureCall) {
						output = ""+inferInteractionType( ((expr as FeatureCallExp).func as InteractionFeatureCall).process) 
					} else {
						output = "void"
					}
				}
			}else if (expr instanceof NumberLiteral)
				output = "float"
			else if (expr instanceof BooleanType)
				output = "bool"
			else if (expr instanceof SystemCallObj)
				output = "systemcall"
			else if (expr instanceof StringLiteral)
				output = "string"
			else if (expr instanceof TypeRef)			
				output = "typeref"
			else if (expr instanceof FeatureCallExp)
			//TODO: Is this correct behavior?
				if ((expr as FeatureCallExp).func instanceof InteractionFeatureCall) {
					output = ""+inferInteractionType( ((expr as FeatureCallExp).func as InteractionFeatureCall).process) 
				} else {
					output = "void"
				}
			else if (expr instanceof IfStatement)
				output = inferIfStatmentReturnType(expr as IfStatement)	
//			else if (expr instanceof AndOrExpression)
//				output = "andor"
			else if (expr instanceof Comparison)
				output = "comparison"
			else if (expr instanceof Equals)
				output = "equals"
			else if (expr instanceof Addition)
				output = "addition"
			else if (expr instanceof Subtraction)
				output = "subtraction"
//			else if (expr instanceof Multi)
//				output = "multi"
			else if (expr instanceof BooleanNegation)
				output = "boolean"
			else if (expr instanceof ArithmeticSigned)
				output = "arithmeticsigned"
			else if (expr instanceof MacroCall)
				output = "macrocall"
			else 
				output = "void"
			}
			
			return output
	}
	
	//TODO: This
	def inferIfStatmentReturnType(IfStatement ifstate){
		var returnType = ""
		//need to make sure all the types match
		//This also has to be recursive to catch all the deep elseifs/elses
		val finalTerm = ifstate.then.reverseView.head
		var output = "";
		if (finalTerm instanceof Field) {
			val ftf = finalTerm as Field
			if (ftf.declaration != null){
				output = (ftf.declaration as DataTypeDeclaration).type.name
			} else if (ftf.agentFieldRef != null){
				output = (ftf.agentFieldRef as AgentFieldReference).agent.name
			} else if (ftf.envFieldRef != null){
				output = (ftf.envFieldRef as EnvironmentFieldReference).env.name
			}
		} else if (finalTerm instanceof Formula) {
			val ftf = finalTerm as Formula
			if (ftf.sym instanceof AgentFieldReference){
				output = (ftf.sym as AgentFieldReference).agent.name;
			} else if (ftf.sym instanceof EnvironmentFieldReference){
				output = (ftf.sym as EnvironmentFieldReference).env.name;
			} else if (ftf.sym instanceof DataTypeDeclaration){
				var dtd = ftf.sym as DataTypeDeclaration
				if (dtd.type != null) {		
					output = dtd.type.name
				} else if (dtd.obj != null){
					output = dtd.obj.name;
				}
			} else if (ftf.sym instanceof FunctionParameter){
				var fp = ftf.sym as FunctionParameter
				if (fp.type != null) {		
					output = fp.type.name
				} else if (fp.obj != null){
					output = fp.obj.name;
				}
			}

		} else if (finalTerm instanceof SelfAssignedFormula) {
			val ftf = finalTerm as SelfAssignedFormula
			if (ftf.ref instanceof AgentFieldReference){
				output = (ftf.ref as AgentFieldReference).agent.name;
			} else if (ftf.ref instanceof EnvironmentFieldReference){
				output = (ftf.ref as EnvironmentFieldReference).env.name;
			} else if (ftf.ref instanceof DataTypeDeclaration){
				var dtd = ftf.ref as DataTypeDeclaration
				if (dtd.type != null) {		
					output = dtd.type.name
				} else if (dtd.obj != null){
					output = dtd.obj.name;
				}
			} else if (ftf.ref instanceof FunctionParameter){
				var fp = ftf.ref as FunctionParameter
				if (fp.type != null) {		
					output = fp.type.name //TODO: Fix bug here w.r.t declaring objects in self
				} else if (fp.obj != null){
					output = fp.obj.name;
				}
			}
		} else if (finalTerm instanceof FunctionCall) {
			output = "void"
		} else if (finalTerm instanceof Expression){
			output = ""+inferExpressionType(finalTerm as Expression)
		} else {
			output = "void"
		}
		
		//TODO: What are these?
		if (ifstate.elseifexpr != null){
			
		} 
		if (ifstate.elseexp != null){
			
		}
		return output;
	}
	
	def parseBodyElement(EObject statement){
		var strOut = "";
		if (statement instanceof Field){
			strOut += printFieldDeclarations(statement as Field)+";"
		} else if (statement instanceof FunctionCall){
			var st = statement as FunctionCall;
			if (st.func != null){
				strOut += (statement as FunctionCall).func.name + "(THINGS TO PASS)"			
			} else if (st.fields != null){
				//do something else
			}
		} else if (statement instanceof Expression){
			strOut += printExpression(statement as Expression)
		} else if (statement instanceof Formula){
			strOut += parseFormula((statement as Formula))
		} else if (statement instanceof SelfAssignedFormula){
			strOut += parseSelfAssignedFormula((statement as SelfAssignedFormula))
		} else if (statement instanceof Raw_Java_Block) {
			strOut += "//Raw Java Block: "+(statement as Raw_Java_Block).name+"\n {"
			for (rawJava : (statement as Raw_Java_Block).rawStatements){
				strOut += rawJava.toString +"\n"
			}
			strOut += "}"			
		}
		return (strOut + ";");	
	}
	
	def generateAdaptations(Agent a) '''
		«FOR adaptation : a.agent_adaptation.adaptation»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «adaptation.name»(«print(printFunctionParameters(adaptation.functionParameters))») {
			«FOR statement : adaptation.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''
	
	def generateSubsystems(Agent a)'''
		«FOR subsystem : a.agent_subSystems.subSystems»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «subsystem.name»(«FOR fp : subsystem.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : subsystem.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''
	
	def createPre(Agent a)'''
		public void pre(){
			postQueue.clear();
		}
	'''
	
	def createPost(Agent a)'''
		public void post(){
			postQueue.forEach(f -> f.apply(this));
				«FOR sb : a.agent_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					updateState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
		}
	'''
	
		def createPre(Environment env)'''
		public void pre(){
			postQueue.clear();
		}
	'''
	
	def createPost(Environment env)'''
		public void post(){
			postQueue.forEach(f -> f.apply(this));
				«FOR sb : env.env_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					updateState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
		}
	'''
	
	def createPost(Group grp)'''
		public void post(){
			postQueue.forEach(f -> f.apply(this));
				«FOR sb : grp.group_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					updateState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
		}
	'''
	
		def createPre(Group g)'''
		public void pre(){
			postQueue.clear();
		}
	'''
	
	def miscRepast(Agent a)'''
		public void assignSpace(Grid<Agent> grid, ContinuousSpace<Agent> space) {
			setGrid(grid);
			setSpace(space);
		}
		@Override
		public void setPosition(Vector2 vector) {
			super.setPosition(vector);
					
			space.moveTo(this, position.getX(), position.getY());
			grid.moveTo(this, (int)position.getX(), (int)position.getY());
		}
		
		public double getCurrentTickCount() {
			return RunEnvironment.getInstance().getCurrentSchedule().getTickCount();
		}
	'''
	
	def miscRepast(Environment env)'''
		public void assignSpace(Grid<Agent> grid, ContinuousSpace<Agent> space) {
			setGrid(grid);
			setSpace(space);
		}
		@Override
		public void setPosition(Vector2 vector){
			super.setPosition(vector);
					
			space.moveTo(this, position.getX(), position.getY());
			grid.moveTo(this, (int)position.getX(), (int)position.getY());
		}
		public double getCurrentTickCount() {
					return RunEnvironment.getInstance().getCurrentSchedule().getTickCount();
				}
	'''
	
//************ENVIRONMENT GENERATION***********//
	def generateParameters(Environment env) '''
		//Fields
		«FOR field : env.env_parameters.fields»
		«IF (field instanceof Field)»
			private «printFieldDeclarations(field as Field)»;
		«ELSEIF (field instanceof Concern)»
		«ENDIF»
		«ENDFOR»
		//Repast specific fields
		private Grid<Agent> grid;
		private ContinuousSpace<Agent> space;
		
		//Getters & Setters
		«FOR field : env.env_parameters.fields»
			«IF (field instanceof Field)»
				«generateGettersSetters(field as Field)»
			«ENDIF»
		«ENDFOR»
		
		//Repast specific getters/setters
		public Grid<Agent> getGrid() {
			return grid;
		}
		public void setGrid(Grid<Agent> grid) {
			this.grid = grid;
		}
		public ContinuousSpace<Agent> getSpace() {
			return space;
		}
		public void setSpace(ContinuousSpace<Agent> space) {
			this.space = space;
		}
	'''
	
	def generateFunctions(Environment env) '''
		«FOR function : env.env_functions.functions»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		public «IF function.returnType != null»«(function.returnType as FunctionParameter).type.name»«ELSE»void«ENDIF» «function.name»(«print(printFunctionParameters(function.functionParameters))») {
			«IF function.returnType != null»«(function.returnType as FunctionParameter).type.name» «function.returnType.name»;«ENDIF»
			«IF function.name == "init"»
				«FOR sb : env.env_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					registerState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
			«ENDIF»
			«FOR statement : function.body»
				«parseBodyElement(statement)»
			«ENDFOR»
			«IF function.returnType != null»return «function.returnType.name»;«ENDIF»
		}
		«ENDFOR»'''	
	
	def generateBehaviors(Environment env)'''
		«FOR behavior : env.env_behaviors.behaviors»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «behavior.name»(«FOR fp : behavior.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : behavior.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''
	
	def generateInteractions(Environment env){
		var output = "";
		for (interaction : env.env_interactions.interactions) {
			output += parseInteraction(interaction)+"\n"
		}
		return output	
	}
	
	def generateAdaptations(Environment env) '''
		«FOR adaptation : env.env_adaptation.adaptation»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «adaptation.name»(«FOR fp : adaptation.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : adaptation.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''
	
	def generateSubsystems(Environment env)'''
		«FOR subsystem : env.env_subSystems.subSystems»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «subsystem.name»(«FOR fp : subsystem.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : subsystem.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''

//************GROUP GENERATION******************//
	def generateParameters(Group grp) '''
		//Fields
		«FOR field : grp.group_parameters.fields»
		«IF (field instanceof Field)»
			private «printFieldDeclarations(field as Field)»;
		«ELSEIF (field instanceof Concern)»
		«ENDIF»
		«ENDFOR»
		//Repast specific fields
		private Grid<Agent> grid;
		private ContinuousSpace<Agent> space;
		
		//Getters & Setters
		«FOR field : grp.group_parameters.fields»
			«IF (field instanceof Field)»
				«generateGettersSetters(field as Field)»
			«ENDIF»
		«ENDFOR»
		
		//Repast specific getters/setters
		public Grid<Agent> getGrid() {
			return grid;
		}
		public void setGrid(Grid<Agent> grid) {
			this.grid = grid;
		}
		public ContinuousSpace<Agent> getSpace() {
			return space;
		}
		public void setSpace(ContinuousSpace<Agent> space) {
			this.space = space;
		}
	'''
		def generateFunctions(Group grp) '''
		«FOR function : grp.group_functions.functions»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		public «IF function.returnType != null»«inferSymbolType((function.returnType as FunctionParameter))»«ELSE»void«ENDIF» «function.name»(«print(printFunctionParameters(function.functionParameters))») {
			«IF function.returnType != null»«inferSymbolType((function.returnType as FunctionParameter))» «function.returnType.name»;«ENDIF»
			«IF function.name == "init"»
				«FOR sb : grp.group_parameters.fields»
				«IF sb instanceof Concern»
					«FOR sbf : sb.stateFields»
					registerState("«sbf.ref.name»",«sbf.ref.name»);
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
			«ENDIF»
			«FOR statement : function.body»
				«parseBodyElement(statement)»
			«ENDFOR»
			«IF function.returnType != null»return «function.returnType.name»;«ENDIF»
		}
		«ENDFOR»'''
	
		def generateBehaviors(Group grp)'''
		«FOR behavior : grp.group_behaviors.behaviors»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «behavior.name»(«FOR fp : behavior.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : behavior.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''

	
	def generateTransmissions(Group grp) '''
		«FOR transmission : grp.group_transmissions.transmissions»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «transmission.name»(«FOR fp : transmission.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : transmission.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''
	
	def generateInternals(Group grp)'''
		«FOR internal : grp.group_internals.internals»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
		private void «internal.name»(«FOR fp : internal.functionParameters»«printFunctionParameter(fp as FunctionParameter)», «ENDFOR») {
			«FOR statement : internal.body»
				«parseBodyElement(statement)»
			«ENDFOR»
		}
		«ENDFOR»		
	'''

//************SYSTEM & CASL LIB GENERATION***********//	

	def generateParameters(System sys) '''
		//Fields
		«FOR field : sys.system_parameters.fields»
		«IF (field instanceof Field)»
			private «printFieldDeclarations(field as Field)»;
		«ELSEIF (field instanceof Concern)»
		«ENDIF»
		«ENDFOR»
		
		//Getters & Setters
		«FOR field : sys.system_parameters.fields»
			«IF (field instanceof Field)»
				«generateGettersSetters(field as Field)»
			«ENDIF»
		«ENDFOR»
		'''
	//This just creates an init method to put various things in 
	def String initialiseSystem(System sys) {
	 	var str = "";
		for(a : sys.agent_types.agent_types) {
			str += "\t"+a.agent_type_name+"List = new ArrayList<"+a.agent_type_name+">();\n"
		}
		
		for (env : sys.environment_types.environment_types) {
			str += "\t"+env.environment_type_name+"List = new ArrayList<"+env.environment_type_name+">();\n"
		}
		return str
	}	
	
	def generateEndConditions(System sys)'''
		//End Condition Fields
		«FOR endCond : sys.end_conditions.end_conditions»
		«IF (endCond.endType == EndConditionTypes.STEPS)»
			private int «endCond.name»;
		«ENDIF»
		«ENDFOR»
		
		//End Condition Getters & Setters
		«FOR endCond : sys.end_conditions.end_conditions»
			«IF (endCond.endType == EndConditionTypes.STEPS)»
			public void set«endCond.name.toFirstUpper»(int «endCond.name») {
				this.«endCond.name» = «endCond.name»;
			}
			public int get«endCond.name.toFirstUpper»() {
				return «endCond.name»;
			}«ENDIF»
		«ENDFOR»
	'''
	
	def generateFunctions(System sys) '''
	«FOR function : sys.system_functions.functions»
«««		need to do signature and return/params. then the body can be done (DAMN JAVA)
	public «IF function.returnType != null»«(function.returnType as FunctionParameter).type.name»«ELSE»void«ENDIF» «function.name»(«print(printFunctionParameters(function.functionParameters))») {
		«IF function.returnType != null»«(function.returnType as FunctionParameter).type.name» «function.returnType.name»;«ENDIF»
		«FOR statement : function.body»
			«IF statement instanceof Field»
			«printFieldDeclarations(statement as Field)»;
			«ELSEIF statement instanceof FunctionCall»
			«(statement as FunctionCall).func.name»(THINGS TO PASS);
			«ELSEIF statement instanceof Expression»
			«printExpression(statement as Expression)»;
			«ELSEIF statement instanceof Formula»
			«(statement as Formula).sym.name» = «printExpression((statement as Formula).expr)»;
			«ELSEIF statement instanceof SelfAssignedFormula»
			this.«(statement as SelfAssignedFormula).ref.name» = «printExpression((statement as SelfAssignedFormula).expr)»;
			«ELSEIF statement instanceof Agent_Call»
			//For all Agents of type «(statement as Agent_Call).agent.name»
			«(statement as Agent_Call).agent.name»List.forEach(«(statement as Agent_Call).agent.name.toFirstLower» -> «(statement as Agent_Call).agent.name.toFirstLower».«(statement as Agent_Call).qnc»);
			«ELSEIF statement instanceof Environment_Call»
			//For all Agents of type «(statement as Environment_Call).env.name»
			«(statement as Environment_Call).env.name»List.forEach(«(statement as Environment_Call).env.name.toFirstLower» -> «(statement as Environment_Call).env.name.toFirstLower».«(statement as Environment_Call).qnc»);
			«ENDIF»
		«ENDFOR»
		«IF function.returnType != null»return «function.returnType.name»;«ENDIF»
	}
	«ENDFOR»'''
		
//*************HELPER METHODS*************//

	def printFunctionParameter (FunctionParameter fp) {
		var strOut = ""
		if (fp.type != null) {
			strOut += fp.type.name +" "+fp.name
		}else if (fp.agent != null){
			strOut += fp.agent.name +" "+fp.name
		}else if (fp.env != null){
			strOut += fp.env.name +" "+fp.name
		} else if (fp.obj != null) {
			strOut += fp.obj.name +" "+fp.name
		}
		return strOut
	}
		
	def String printFunctionParameters(EList<Symbol> fps){
		val parameterSize = fps.size
		var strOut = "";
		if (parameterSize == 0) {
			return ""
		} else {
			for (i : 0 ..< parameterSize -1){
				strOut += printFunctionParameter(fps.get(i) as FunctionParameter)+', '			
			}
			strOut += printFunctionParameter(fps.get(parameterSize-1) as FunctionParameter)
			return strOut
		}		
	}
	
	def String printRuleExceptionArgs(EList<CAS_Rule_Exception> ruleArgs){
		val parameterSize = ruleArgs.size
		var strOut = "";
		if (parameterSize == 0) {
			return ""
		} else {
			for (i : 0 ..< parameterSize -1){
				strOut += "CAS_Rule_Exception."+(ruleArgs.get(i) as CAS_Rule_Exception).toString.toUpperCase+', '				
			}	

			strOut += "CAS_Rule_Exception."+(ruleArgs.get(parameterSize - 1) as CAS_Rule_Exception).toString.toUpperCase
			return strOut
		}
	}
	
	def String printFunctionArgs(EList<Expression> far) {
		val parameterSize = far.size
		var strOut = "";
		if (parameterSize == 0) {
			return ""
		} else {
			for (i : 0 ..< parameterSize -1){
				strOut += printExpression(far.get(i) as Expression)+', '			
			}
			strOut += printExpression(far.get(parameterSize-1) as Expression)
			return strOut
		}	
	}
		
	def printExpression(EObject expr){
		if (expr instanceof Expression){ //is this needed, feels redundant
			if (expr instanceof SelfCallExpr)
			'''«parseSelfCall(expr as SelfCallExpr)»'''
			else if (expr instanceof NumberLiteral)
				'''«(expr as NumberLiteral).value»'''
			else if (expr instanceof BooleanType)
				'''«(expr as BooleanType).bool»'''
			else if (expr instanceof SystemCallObj)
				'''«(expr as SystemCallObj).sysCall.call»'''
			else if (expr instanceof StringLiteral)
				'''"«(expr as StringLiteral).value»"'''
			else if (expr instanceof TypeRef)
				'''«(expr as TypeRef).type.name»«««IF expr.call != null ».«expr.call.name»«ENDIF»
'''
			else if (expr instanceof FeatureCallExp)
				'''«printFeatureCall((expr as FeatureCallExp).func)»'''
			else if (expr instanceof IfStatement)
				printIfStatement((expr as IfStatement))	
//			else if (expr instanceof AndOrExpression)
//				'''«printExpression((expr as AndOrExpression).left)» «(expr as AndOrExpression).op» «printExpression((expr as AndOrExpression).right)»'''
			else if (expr instanceof Comparison)
				'''«printExpression((expr as Comparison).left)» «(expr as Comparison).op» «printExpression((expr as Comparison).right)»'''
			else if (expr instanceof Equals)
				'''«printExpression((expr as Equals).left)» == «printExpression((expr as Equals).right)»'''
//			else if (expr instanceof NotEqual)
//				'''«printExpression((expr as NotEqual).left)» != «printExpression((expr as NotEqual).right)»'''
			else if (expr instanceof Addition)
				'''«printExpression((expr as Addition).left)» «(expr as Addition).op» «printExpression((expr as Addition).right)»'''
			else if (expr instanceof Subtraction)
				'''«printExpression((expr as Subtraction).left)» «(expr as Subtraction).op» «printExpression((expr as Subtraction).right)»'''	
//			else if (expr instanceof Multi)
//				'''«printExpression((expr as Multi).left)» «(expr as Multi).op» «printExpression((expr as Multi).right)»'''
			else if (expr instanceof BooleanNegation)
				'''!«printExpression((expr as BooleanNegation).expression)»'''
			else if (expr instanceof ArithmeticSigned)
				'''-«printExpression((expr as ArithmeticSigned).expression)»'''
			else if (expr instanceof MacroCall)
				'''«parseMacro((expr as MacroCall),"")»'''
			else if (expr instanceof NullTypeLiteral)
				'''null'''
			else if (expr instanceof FunctionCallExpr)
				'''«parseFunctionCall((expr as FunctionCallExpr).funcCall)»'''
			else if (expr instanceof EnumCallExpr)
				'''«(expr as EnumCallExpr).enumCall.en.name»_ENUM.«(expr as EnumCallExpr).enumCall.en.name».«(expr as EnumCallExpr).enumCall.entype.name»'''
			else '''ERROR111: ''' 
		} 
	}
	
	//This can easily be changed and reduced
	def printExpression(Expression expr, String name){
		if (expr instanceof MacroCall)
			'''«parseMacro((expr as MacroCall),name)»'''
		else
			printExpression(expr)
	}		
	
	def parseFormula(Formula formula){
		var strOut = "";
		strOut += formula.sym.name
		if (formula.objField != null){
			strOut += "."+formula.objField.name
		} 
		strOut += " = "+printExpression(formula.expr)
		return strOut;
	}
	
	def parseSelfAssignedFormula(SelfAssignedFormula saf){
		var strOut = "";
		strOut += "this."+saf.ref.name;
		if (saf.objField != null){
			strOut += "."+saf.objField.name
		}
		strOut += " = "+printExpression(saf.expr)
		return strOut;
	}
	
	def parseSelfCall(SelfCallExpr sce){
		val sc = sce.selfCall
		var output = "this"
		if (sc.fc != null){
			output += "."+parseFunctionCall(sc.fc)
		} else if (sc.ref != null){
			output += "."+ sc.ref.name
		} else if (sc.fec != null){
			output += "."+printFeatureCall(sc.fec)
		}
		return output
	}
	
	def parseFunctionCall(FunctionCall fc){ 
		var output = "";
		output += fc.obj.name //TODO: Why is this given NPEs? That's impossible...
		if (fc.func != null){
			output += "."+fc.func.name
			output +="("+printFunctionArgs(fc.inputs) +")"
			
		} else if (fc.fields != null){
			for (fields : fc.fields){
				output += "."+fields.name
			}
		}		
		return output
	}
	
	def printFeatureCall(FeatureCall featcall) {
		val fc = featcall.fc
		if (fc instanceof AdaptiveProcessFeatureCall)
		'''«(fc as AdaptiveProcessFeatureCall).process.name»(«printFunctionArgs(fc.inputs)»)'''
		else if (fc instanceof AgentInteractionFeatureCall)
		'''«(fc as AgentInteractionFeatureCall).agt.name».«(fc as AgentInteractionFeatureCall).process.name»(«printFunctionArgs(fc.inputs)»)'''
		else if (fc instanceof EnvironmentInteractionFeatureCall)
		'''«(fc as EnvironmentInteractionFeatureCall).env.name».«(fc as EnvironmentInteractionFeatureCall).process.name»(«printFunctionArgs(fc.inputs)»)'''
		else if (fc instanceof InteractionFeatureCall)
		'''«(fc as InteractionFeatureCall).process.name»(«printFunctionArgs(fc.inputs)»)'''
		else if (fc instanceof FunctionFeatureCall)
		'''«(fc as FunctionFeatureCall).process.name»(«printFunctionArgs(fc.inputs)»)'''
		else if (fc instanceof BehaviorFeatureCall) {
			 var bfc = (fc as BehaviorFeatureCall);
			 if (bfc.process.behavior_reaction_time == BehaviorReactionTime.INSTANT) {
				'''«bfc.process.name»(«printFunctionArgs(fc.inputs)»)'''
			} else if (bfc.process.behavior_reaction_time == BehaviorReactionTime.DELAYED) {
				var str = "";
				str += "Function<Object,Void> fn = new Function<Object,Void>() {"
				+"\n\tpublic Void apply(Object o) {"
				+"\n\t\to."+bfc.process.name+"("+printFunctionArgs(fc.inputs)+");"
				+"\n\t\treturn null;"
				+"\n\t}"
				+"\n}"
				+"\npostQueue.add(fn);"
				return str;							
			} else if (bfc.process.behavior_reaction_time == BehaviorReactionTime.STEP){
				//TODO: This******
				if (bfc.process.reaction_time_parm != null){
					//Need to do a throwaway delayed call of this function					
					var str = "\tISchedule schedule = RunEnvironment.getInstance().getCurrentSchedule();\n"
					str += "\tScheduleParameters delayed_"+bfc.process.name+" = ScheduleParameters.createOneTime(getCurrentTickCount()+"+printExpression(bfc.process.reaction_time_parm)+");\n"
					str += "\tschedule.schedule(delayed_"+bfc.process.name+",this,\""+bfc.process.name+"\");\n"
					return str;
				}				
			}				
		} else '''ERROR WITH FEATURE CALL:«fc.toString»'''	
	}
	
	def printFieldDeclarations(Field f){
		//Prints out the type, var name and expression if it has one.
		var output = "";		
		if (f.declaration != null){
			val fdt = f.declaration as DataTypeDeclaration
			if (fdt.type != null){
				if (fdt.expr != null) {
					output += fdt.type.name +" "+fdt.name+" = "+printExpression(fdt.expr,fdt.name)
				}else { 
					if (fdt.type.name.compareTo(StringType.name) == 0) {
						output += fdt.type.name+" "+fdt.name+" = \"\""
					} else {
						output += fdt.type.name+" "+fdt.name
					}
				}
			}else if (fdt.obj != null){
				if (fdt.obj instanceof uofa.lbirdsey.castle.casl.Enum){
					if (fdt.expr != null){
						output += fdt.obj.name+"_ENUM."+fdt.obj.name+" "+fdt.name+" = "+printExpression(fdt.expr,fdt.name)
					} else {
						if (fdt.useObj != null){
							output += fdt.obj.name+"<"+fdt.useObj.name+"> "+fdt.name+" = new "+fdt.obj.name+"<"+fdt.useObj.name+">()"
						} else {
							output += fdt.obj.name+"_ENUM."+fdt.obj.name+" "+fdt.name	
						}									
					}
				} else if (fdt.obj instanceof uofa.lbirdsey.castle.casl.Object){
					if (fdt.expr != null){
						if (fdt.useObj != null){
							output += fdt.obj.name+"<"+fdt.useObj.name+"> "+fdt.name+" = "+printExpression(fdt.expr,fdt.name)
						} else {
							output += fdt.obj.name+" "+fdt.name+" = "+printExpression(fdt.expr,fdt.name)
						}
					} else {
						if (fdt.useObj != null){
							output += fdt.obj.name+"<"+fdt.useObj.name+"> "+fdt.name+" = new "+fdt.obj.name+"<"+fdt.useObj.name+">()"
						} else {
							output += fdt.obj.name+" "+fdt.name+" = new "+fdt.obj.name+"()"	
						}									
					}
				}
			}
		} else if (f.agentFieldRef != null){
			val afr = f.agentFieldRef as AgentFieldReference		
				output += afr.agent.name.toFirstUpper+" "+afr.name
				if (afr.assignment != null){
					output += " = "+printExpression(afr.assignment)
				}
				output += ";"
		} else if (f.envFieldRef != null){
			val efr = f.envFieldRef as EnvironmentFieldReference
			output += efr.env.name.toFirstUpper + " "+ efr.name
			if (efr.assignment != null){
					output += " = "+printExpression(efr.assignment)
			}
			output += ";"			
		}
	}

	def printIfStatement(IfStatement is){
		var output = "";
		output += "if (" + printExpression(is.condition) +") {\n"
		for (expr : is.then){
			output += "\t\t";
			if (expr instanceof Expression){
				output += printExpression(expr);				
			} else if (expr instanceof Formula){
				output += parseFormula(expr as Formula);
			} else if (expr instanceof SelfAssignedFormula){
				output += parseSelfAssignedFormula(expr as SelfAssignedFormula)
			} else if (expr instanceof Field){
				output += printFieldDeclarations(expr as Field);
			}
			output += ';\n'			
		}
		output += "}"
		if (is.elseifexpr != null){
			for (cond : is.elseifexpr){
				output += " else if (" + printExpression(cond.elseifCond) +") {\n"
				for (expr : cond.elseifthen){
					output += "\t";
					if (expr instanceof Expression){
						output += printExpression(expr);				
					} else if (expr instanceof Formula){
						output += parseFormula(expr as Formula);
					} else if (expr instanceof SelfAssignedFormula){
						output += parseSelfAssignedFormula(expr as SelfAssignedFormula)
					} else if (expr instanceof Field){
						output += printFieldDeclarations(expr as Field);
					}
					output += ';\n'			
				}
				output += "\t}"
			}
		}
		
		if (!is.elseexp.isEmpty){
			output += " else {\n"
			for (expr : is.elseexp){
				output += "\t";
				if (expr instanceof Expression){
					output += printExpression(expr);
				} else if (expr instanceof Formula){
					output += parseFormula(expr as Formula);
				} else if (expr instanceof SelfAssignedFormula){
					output += parseSelfAssignedFormula(expr as SelfAssignedFormula)
				} else if (expr instanceof Field){
					output += printFieldDeclarations(expr as Field);
				}
				output += ';\n'			
			}
			output += "}"
		}		
		return output;
	}
	
	def String newLine(){
		return "\n";
	}
	
	//Highly Repast Specific
	def parseMacro(MacroCall mc, String name){
		var output = "";		
		var macro = mc.macroCall.macro
		if (macro instanceof CASL_Macro_Neighbours){
			output += "null;\n"
			var ngh = (macro as CASL_Macro_Neighbours)
			if (ngh.worldType == WorldType.GRID){
				output += "GridPoint pt = grid.getLocation(this);\nGridCellNgh<"+ngh.searchType.name.toFirstUpper+"> nghCreator;\n"
				output += "nghCreator = new GridCellNgh<"+ngh.searchType.name.toFirstUpper+">(grid, pt, "+ngh.searchType.name.toFirstUpper+".class, "+ngh.dist+", "+ngh.dist+");\n"
				output += "List<GridCell<"+ngh.searchType.name.toFirstUpper+">> gridCells = nghCreator.getNeighborhood(false);\n"
				output += "List<"+ngh.searchType.name.toFirstUpper+"> "+name+" = new ArrayList<"+ngh.searchType.name.toFirstUpper+">();\n"
				output += "for (GridCell<"+ngh.searchType.name.toFirstUpper+"> "+ngh.searchType.name.toFirstLower+"s : grid"+ngh.searchType.name.toFirstUpper+"s) {\n"	
				output += "\t"+ngh.searchType.name.toFirstUpper+" tmp"+ngh.searchType.name.toFirstUpper+" = "+ngh.searchType.name.toFirstLower+"s.items().iterator().next();\n"
				output += "\t"+name+".add(tmpCell);\n}"
		
			} else if (ngh.worldType == WorldType.SPACE) {
				
			}
		} else if (macro instanceof CASL_Macro_FilterAndFunction) {
			var mac = (macro as CASL_Macro_FilterAndFunction)
			if (mac.sym != null){
				var decl = mac.sym
				output += decl.name+".stream().filter("+printExpression(mac.cond)+")."+mac.misc.toString
			}
		} else if (macro instanceof CASL_Macro_CountConditions) {
			var mac = (macro as CASL_Macro_CountConditions)
			if (mac.sym != null) {
				output += mac.sym.name+".stream().filter("+printExpression(mac.cond)+").count()"
			}
		} else if (macro instanceof CASL_Macro_Random){
			var mac = (macro as CASL_Macro_Random)
			if (mac.type == numType.INT){
				if (mac.high == null){
					output += "Utilities.generateRandomRangeInteger(0,"+printExpression(mac.low)+");"
				} else {
					output += "Utilities.generateRandomRangeInteger("+printExpression(mac.low)+","+printExpression(mac.high)+");"
				}
				
			} else if (mac.type == numType.FLOAT){
				if (mac.high == null){
					output += "Utilities.generateRandomRangeDouble(0,"+printExpression(mac.low)+");"
				} else {
					output += "Utilities.generateRandomRangeDouble("+printExpression(mac.low)+","+printExpression(mac.high)+");"
				}
			}
		} else if (macro instanceof CASL_Macro_ForEach) {
			var mac = (macro as CASL_Macro_ForEach)
			if (mac.sym != null) {
//				SOMEHOW INFER THE TYPES FOR THIS
				output += mac.sym.name+".forEach("+"Function<Object,Void> fn = new Function<Object,Void>() {"
				+"\n\tpublic Void apply(Object o) {"
				+"\n\t\to."+printExpression(mac.expr)+";"
				+"\n\t\treturn null;"
				+"\n\t}"
				+"\n}"+")"
			}
		} else if (macro instanceof CASL_Macro_Print) {
			var mac = (macro as CASL_Macro_Print)
			output += "System.out.println(\""+mac.str+"\");\n"
		}
		return output;
	}
	
	
	def determineTypeFromExpr(Expression expr){
		var output = "";
		//TODO:this 		
	}
	
	def inferSymbolType(Symbol sym){
		var output = "";
		if (sym instanceof AgentFieldReference){
			output = "sym=afr"
		} else if (sym instanceof EnvironmentFieldReference){
			output = "sym=afr"
		} else if (sym instanceof FunctionParameter){
			var fp = sym as FunctionParameter;
			output = inferFunctionParameterType(fp);
		} else if (sym instanceof DataTypeDeclaration){
			var dtd = sym as DataTypeDeclaration;
			output = inferTypeFromDeclaration(dtd);
		}
	}
	
	
	/******SYSTEM LEVEL GENERATION STUFF **********/
	/**********lots of this will be needed across agents and environments */
	def String generateCASChecker(System sys){		
		var str = "";
		//Init the CASFeatures system
		str += "private CASFeatures casFeatures = new CASFeatures(\""+sys.name+"\",ruleSet);\n"
		str += "public void registerAgentState_Init(Agent agent) {\n\tcasFeatures.registerAgentState_Init(agent); \n}\n"
		str += "public void registerEnvironmentState_Init(Environment env) {\n\tcasFeatures.registerEnvironmentState_Init(env); \n}"
		str += "public void runCASFeatureChecks(){\n\tcasFeatures.newCheck();\n/*MANUALcasFeatures.addAgentListForNewCheck(\"Cell\", CellList);*/\n\tcasFeatures.runChecks();\n}\n"
		str += "public void finalCASFeatureCall(){\n\tcasFeatures.finalCall();\n}\n"
		return str 
	}
	
	def String generateDebugFunctions(System sys){
		var str = "";
		str += "/*****Debugging Methods*****/\n"
		str += "public long time = 0;\n"
		str += "public long lastCall = 0;\n"
		str += "//Every time this is called it adds\n"
		str += "public void initTimer(){\n"
			str += "\ttime = 0;\n"
			str += "\tlastCall = System.currentTimeMillis();\n"
		str += "}\n"
		str += "public void timer(){\n"
			str += "\tlong tmpCall = System.currentTimeMillis();\n"
			str += "\ttime += (tmpCall - lastCall);\n"
			str += "\tlastCall = tmpCall;\n"
			str += "\t//		System.out.println(\"time: \" + time);\n"
		str += "}\n"
		str += "public void printTimer(){\n"
			str += "\tSystem.out.print(time+\",\");\n"
		str += "}\n"
		
		str += "/****Results Exporting*****/\n"
		str += "String outPath = \"/output/\"+(name.replaceAll(\" \",\"\"))+\"_\"+Utilities.generateTimeStamp() +\".txt\";\n"
		str += "public void sendToFile(String str){\n"
			str += "\tUtilities.writeToFile(str, System.getProperty(\"user.dir\")+outPath);\n"
		str += "}\n"
		
		str += "String runningString = \"\";\n"
		
		str += "public void addToCurrentLog(String str){\n"
			str += "runningString += str + \"\\n\""
		str += "}\n"
		
		str += "public void finalCall(){\n"
			str += "\tfinalCASFeatureCall();\n"
			str += "\tsendToFile(runningString);\n"
		str += "}\n"

	str += "public void prefixStepNumber(){\n"
		str += "\trunningString += \"step:\t\"+(int)getCurrentTickCount()+\" \";\n"
	str += "}\n"

		return str
		
	}

	/******THE REPAST CRAP (SINCE IT WON'T GO IN IT'S OWN FILE) **********/
	def String repastBuildInitialiser(System sys){
		var str = "";
		str = "public Context<Agent> build (Context<Agent> context) {\n\tcontext.setId(\""+sys.name+"\");\n"
		str += "\t//Initialise lists to contain Agents and Environments\n"
		str += sys.initialiseSystem()
		str += "\n\t//Get parameters from Repast\n\tParameters params = RunEnvironment.getInstance().getParameters();\n"

		var paramGetters = "";
		paramGetters += "\tint areaSizeX = params.getValue(\"Size (X)\");\n"
		paramGetters += "\tint areaSizeY = params.getValue(\"Size (Y)\");\n"
		for (field : sys.system_parameters.fields){
			var ff = (field as Field)
			var fdt = ff.declaration
			paramGetters += "\tset"+fdt.name.toFirstUpper+"(params.getValue(\""+fdt.name+"\"));\n"			
		}
		
		//Stuff for termination
		var finalSteps = "";
		for (endCond : sys.end_conditions.end_conditions){
			if (endCond.endType == EndConditionTypes.STEPS) {
				paramGetters += "\tset"+endCond.name.toFirstUpper+"(params.getValue(\""+endCond.name+"\"));\n"
				finalSteps = "\tRunEnvironment.getInstance().endAt(get"+endCond.name.toFirstUpper+"());"
			}
		}
		str += paramGetters + "\n"
		str += finalSteps + "\n"
		//Using the system parameters. How do we write this to the Repast Xml file though?
		//Using another code generator!
		
		//Setting up the display (although the manual part of Repast may prevent us from having to
		//hard code anything (however in the future it would be useful to skip any manual stuff)
		//Space set up		
		var spaceSetUp = "\t//Initialise the visual stuff and assign Agents places in space\n"
		spaceSetUp += "\tGridFactory gridFactory = GridFactoryFinder.createGridFactory(null);\n"
		spaceSetUp += "\tGrid<Agent> grid = gridFactory.createGrid(\"grid\", context, new GridBuilderParameters<Agent>(new StrictBorders(),new SimpleGridAdder<Agent>(), false, areaSizeX, areaSizeY));\n"
		
		spaceSetUp += "\tContinuousSpaceFactory spaceFactory = ContinuousSpaceFactoryFinder.createContinuousSpaceFactory(null);\n"
		spaceSetUp += "\tContinuousSpace<Agent> space = spaceFactory.createContinuousSpace(\"space\", context, new SimpleCartesianAdder<Agent>(), new repast.simphony.space.continuous.StrictBorders(), areaSizeX, areaSizeY);\n"
		str += spaceSetUp
		
		var casFeatureSetup = "\n";
		casFeatureSetup += "\t//Set Schedule for CASFeatures ()\n"
		casFeatureSetup += "\tISchedule schedule;\n"
		casFeatureSetup += "\tschedule = RunEnvironment.getInstance().getCurrentSchedule();\n"
		casFeatureSetup += "\tScheduleParameters casFeatureRunner = ScheduleParameters.createRepeating(0,1,ScheduleParameters.LAST_PRIORITY + 1);\n"
		casFeatureSetup += "\tschedule.schedule(casFeatureRunner,this,\"runCASFeatureChecks\");\n"
		
		casFeatureSetup += "\n\t//Timing\n"
		casFeatureSetup += "\tScheduleParameters stepper = ScheduleParameters.createRepeating(0,1,ScheduleParameters.FIRST_PRIORITY);\n"
 		casFeatureSetup += "\tschedule.schedule(stepper,this,\"prefixStepNumber\");\n"
		casFeatureSetup += "\tScheduleParameters timerSchedule = ScheduleParameters.createRepeating(0,1,ScheduleParameters.LAST_PRIORITY + 100);\n"
		casFeatureSetup += "\tschedule.schedule(timerSchedule,this,\"timer\");\n"
		casFeatureSetup += "\tScheduleParameters initTimerSchedule = ScheduleParameters.createOneTime(0,ScheduleParameters.FIRST_PRIORITY);\n"
		casFeatureSetup += "\tschedule.schedule(initTimerSchedule,this,\"initTimer\");\n"
		casFeatureSetup += "\tScheduleParameters printFinalTime = ScheduleParameters.createAtEnd(ScheduleParameters.LAST_PRIORITY);\n"
		casFeatureSetup += "\tschedule.schedule(printFinalTime,this,\"printTimer\");\n"
		casFeatureSetup += "\tschedule.schedule(printFinalTime,this,\"finalCall\");\n"
		str += casFeatureSetup;
		
		//Initialse Agents/Environments
		//TODO: This needs to be done asap otherwise there's way too much copy & pasting of crap
		//HOW CAN WE DO ALL OF THIS AUTOMATICALLY (check SYSTEM note in SocialNetwork.casl)
		var agentSetUp = "\n\t//Initialse Agents/Environments"
		var idGenCounter = 0;
		for (agent : sys.agent_types.agent_types){
			agentSetUp += "\n\t//Create the "+agent.agent_type_name+" population\n"
			agentSetUp += "\tfor (int i = 0; i < get"+agent.agent_type_name+"Population();i++) {\n"			
			agentSetUp += "\t\t"+agent.agent_type_name+" tmp"+agent.agent_type_name+" = new "+agent.agent_type_name+"(space, grid, \""+agent.agent_type_name+"_\"+i"+",new Vector2(0,0));\n" //TODO: How do we handle init specifics??
			
			agentSetUp += "\t\t"+agent.agent_type_name+"List.add(tmp"+agent.agent_type_name+");\n"
			agentSetUp += "\t\tcontext.add(tmp"+agent.agent_type_name+");\n"
			
			
			//specifics
			
			
			agentSetUp +="\t\ttmp"+agent.agent_type_name+".init();\n"
			agentSetUp += "\t\tregisterAgentState_Init(tmp"+agent.agent_type_name+");\n"
			agentSetUp += "\t}\n"
		}
		
//		for (int i = 0; i < getAntPopulation(); i++){
//			Ant tmpAnt = new Ant(space,grid,"Ant"+i, getColonyLocation());
//			
//			AntList.add(tmpAnt);
//			context.add(tmpAnt);
//			tmpAnt.setPosition(getColonyLocation());
//			tmpAnt.init();
//			tmpAnt.setBounds(areaSizeX, areaSizeY);
//			registerAgentState_Init(tmpAnt);
//		} 
		str += agentSetUp;
		
		var envSetUp = ""
		for (env : sys.environment_types.environment_types){
			envSetUp +="\t//Creating the "+env.environment_type_name+"\n"
			envSetUp += "\t"+env.environment_type_name +" "+env.environment_type_name.toFirstLower +" = new "+env.environment_type_name+"(space,grid,\"The"+env.environment_type_name+"\",new Vector2(0,0));\n" //TODO: Again, specifics?
			
			
//			Colony colony = new Colony(space, grid, "TheColony", getColonyLocation());
//			colony.setSize(systemSize);
//			context.add(colony);
//			colony.init();
//			colony.placeFood(amountOfFood);

			//specifics
			envSetUp += "\t"+env.environment_type_name.toFirstLower+".init();\n"
			
			envSetUp += "\t"+env.environment_type_name+"List.add("+env.environment_type_name.toFirstLower+");\n"

		}
		
		str += envSetUp;
		
		str +="\n\tinit();\n\ttheContext = context;\n";
		
				
		str += "\n\treturn context;"
		str += "\n}\n"
		
		//TODO: Move this later
		str += "public double getCurrentTickCount(){\n\treturn RunEnvironment.getInstance().getCurrentSchedule().getTickCount();\n}";
		return str
	}
	
	def String generateSystemBuilder(){
		var imports = "";
		imports = 
"import interLib.Utilities;

import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import repast.simphony.context.Context;
import repast.simphony.dataLoader.ContextBuilder;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ISchedule;
import repast.simphony.engine.schedule.ScheduleParameters;
import repast.simphony.parameter.Parameters;
import castleComponents.Capsule;
import castleComponents.Entity;
import castleComponents.EntityID;
import castleComponents.Environment;
import castleComponents.Logger;
import castleComponents.Message;
import castleComponents.MessageQueue;
import castleComponents.MessageType;
import castleComponents.Phase;"
					return imports;				
	}
	
	def String generateAgentBuilder(){
		//imports
		val imports = 
"
import java.util.List;
import java.util.function.Function;
import repast.simphony.context.Context;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ISchedule;
import repast.simphony.engine.schedule.ScheduleParameters;
import repast.simphony.query.space.grid.GridCell;
import repast.simphony.query.space.grid.GridCellNgh;
import repast.simphony.space.continuous.ContinuousSpace;
import repast.simphony.space.grid.Grid;
import repast.simphony.space.grid.GridPoint;
//import interLib.Agent;
import interLib.Interaction;
import interLib.SystemDescription;
import interLib.Utilities;
import interLib.Vector2;
import interLib.State;
import interLib.Map2D;
import casFeatures.CASFeatures;
import casFeatures.CASRuleSet;
import casFeatures.CASLib.*;
import interLib.Utilities;

import java.awt.Color;
import java.util.ArrayList;

import castleComponents.Agent;"			
		return imports
	}
	
	def String generateEnvironmentBuilder(){
		//imports
		var imports = "";
		imports = 
"import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import repast.simphony.context.Context;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ISchedule;
import repast.simphony.engine.schedule.ScheduleParameters;
import repast.simphony.query.space.grid.GridCell;
import repast.simphony.query.space.grid.GridCellNgh;
import repast.simphony.space.continuous.ContinuousSpace;
import repast.simphony.space.grid.Grid;
import repast.simphony.space.grid.GridPoint;
//import interLib.Agent;
import interLib.Interaction;
import interLib.SystemDescription;
import interLib.Utilities;
import interLib.Vector2;
import interLib.State;
import interLib.Map2D;
import casFeatures.CASFeatures;
import casFeatures.CASRuleSet;
import casFeatures.CASLib.*;
import repast.simphony.context.Context;
import repast.simphony.context.DefaultContext;
import castleComponents.Environment;
import castleComponents.Capsule;
import castleComponents.representations.GridRep;"			
		return imports
	}
	
	def String scheduleInit(Agent a){
		var sig = "";
		sig = "@Override \n public void initialiseSchedule(double startTime, double startDelay) {\n"	
		sig += "\tISchedule schedule;\n"		
		sig += "\tschedule = RunEnvironment.getInstance().getCurrentSchedule();\n"
		sig += "\t//Set up pre() schedule\n\tScheduleParameters pre_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.FIRST_PRIORITY);\n"
		sig += "\t//Set up post() schedule\n\tScheduleParameters post_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.LAST_PRIORITY + 1);\n"
		//Determine what methods need to be scheduled and when
		//Interactions
		var schedules = newArrayList
		sig += "\t//Interaction Schedules\n"
		for (interaction : a.agent_interactions.interactions) {
			if (interaction.trigger_type == InteractionTriggerTypes.STEP){
				//Expecting a numeric value
				var steps = (interaction.triggerParam.expr as NumberLiteral).value
				var schedule = interaction.name + "_Schedule"
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+steps+",2);"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+interaction.name+"\");")								
			}					
		}
		sig += "\n\t//Adaptation Schedules\n"
		for (adaptation : a.agent_adaptation.adaptation) {
			if (adaptation.adaptationDelay == AdaptationDelay.POST){
				var schedule = adaptation.name +"_Schedule"
				//THIS HAS HARD CODING IN IT. BE WARNED
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+1+",ScheduleParameters.LAST_PRIORITY + 1);"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+adaptation.name+"\");")		
			}	
		}				
		sig += "\n\t//Behavior Schedules\n"
		for (behavior : a.agent_behaviors.behaviors) {
			if (behavior.behavior_reaction_time == BehaviorReactionTime.REPEAT){
				var schedule = behavior.name +"_Schedule"
				//THIS HAS HARD CODING IN IT. BE WARNED
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+1+");"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+behavior.name+"\");")		
			}	
		}	
		sig += "\n"
		sig += "\t//Send schedules to Scheduler\n"
		for (str : schedules){
			sig += "\t"+str+"\n"
		}
		sig += "\tschedule.schedule(pre_Schedule,this,\"pre\");\n"
		sig += "\tschedule.schedule(post_Schedule,this,\"post\");\n"
		sig += '}'
		return sig;			
	}
	
	def String scheduleInit(Environment env){
		var sig = "";
		sig = "@Override \n public void initialiseSchedule(double startTime, double startDelay) {\n"	
		sig += "\tISchedule schedule;\n"		
		sig += "\tschedule = RunEnvironment.getInstance().getCurrentSchedule();\n"
		sig += "\t//Set up pre() schedule\n\tScheduleParameters pre_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.FIRST_PRIORITY);\n"
		sig += "\t//Set up post() schedule\n\tScheduleParameters post_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.LAST_PRIORITY + 1);\n"
		sig += "\t//Set up end() schedule\n\tScheduleParameters end_Schedule = ScheduleParameters.createAtEnd(ScheduleParameters.LAST_PRIORITY);"
		//Determine what methods need to be scheduled and when
		//Interactions
		var schedules = newArrayList
		sig += "\t//Interaction Schedules\n"
		for (interaction : env.env_interactions.interactions) {
			if (interaction.trigger_type == InteractionTriggerTypes.STEP){
				//Expecting a numeric value
				var steps = (interaction.triggerParam.expr as NumberLiteral).value
				var schedule = interaction.name + "_Schedule"
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+steps+",2);"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+interaction.name+"\");")								
			}					
		}
		sig += "\n\t//Adaptation Schedules\n"
		for (adaptation : env.env_adaptation.adaptation) {
			if (adaptation.adaptationDelay == AdaptationDelay.POST){
				var schedule = adaptation.name +"_Schedule"
				//THIS HAS HARD CODING IN IT. BE WARNED
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+1+",ScheduleParameters.LAST_PRIORITY + 1);"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+adaptation.name+"\");")		
			}	
		}				
		for (behavior : env.env_behaviors.behaviors) {
			if (behavior.behavior_reaction_time == BehaviorReactionTime.STEP){
				var schedule = behavior.name +"_Schedule"
				//THIS HAS HARD CODING IN IT. BE WARNED
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+1+");"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+behavior.name+"\");")		
			}	
		}	
		sig += "\n"
		sig += "\t//Send schedules to Scheduler\n"
		for (str : schedules){
			sig += "\t"+str+"\n"
		}
		sig += "\tschedule.schedule(pre_Schedule,this,\"pre\");\n"
		sig += "\tschedule.schedule(post_Schedule,this,\"post\");\n"
		sig += "\tschedule.schedule(end_Schedule,this,\"end\");\n"
		sig += '}'
		return sig;			
	}
	
	def String scheduleInit(Group grp){
		var sig = "";
		sig = "@Override \n public void initialiseSchedule(double startTime, double startDelay) {\n"	
		sig += "\tISchedule schedule;\n"		
		sig += "\tschedule = RunEnvironment.getInstance().getCurrentSchedule();\n"
		sig += "\t//Set up pre() schedule\n\tScheduleParameters pre_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.FIRST_PRIORITY);\n"
		sig += "\t//Set up post() schedule\n\tScheduleParameters post_Schedule = ScheduleParameters.createRepeating(1,1,ScheduleParameters.LAST_PRIORITY + 1);\n"
		//Determine what methods need to be scheduled and when
		//Interactions
		var schedules = newArrayList
		sig += "\n\t//Behavior Schedules\n"
		for (behavior : grp.group_behaviors.behaviors) {
			if (behavior.behavior_reaction_time == BehaviorReactionTime.REPEAT){
				var schedule = behavior.name +"_Schedule"
				//THIS HAS HARD CODING IN IT. BE WARNED
				var scheduleSetup = "ScheduleParameters " + schedule + " = ScheduleParameters.createRepeating(1,"+1+");"
				sig += "\t"+scheduleSetup+"\n"
				schedules.add("schedule.schedule("+schedule+",this,\""+behavior.name+"\");")		
			}	
		}	
		sig += "\n"
		sig += "\t//Send schedules to Scheduler\n"
		for (str : schedules){
			sig += "\t"+str+"\n"
		}
		sig += "\tschedule.schedule(pre_Schedule,this,\"pre\");\n"
		sig += "\tschedule.schedule(post_Schedule,this,\"post\");\n"
		sig += '}'
		return sig;			
	}
}