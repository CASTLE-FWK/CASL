/*
 * generated by Xtext 2.11.0
 */
package uofa.lbirdsey.castle.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uofa.lbirdsey.castle.casl.AdaptiveProcess;
import uofa.lbirdsey.castle.casl.AdaptiveProcessFeatureCall;
import uofa.lbirdsey.castle.casl.AdaptiveProcesses;
import uofa.lbirdsey.castle.casl.Addition;
import uofa.lbirdsey.castle.casl.Agent;
import uofa.lbirdsey.castle.casl.AgentFieldReference;
import uofa.lbirdsey.castle.casl.AgentInteraction;
import uofa.lbirdsey.castle.casl.AgentInteractionFeatureCall;
import uofa.lbirdsey.castle.casl.AgentInteractions;
import uofa.lbirdsey.castle.casl.Agent_Call;
import uofa.lbirdsey.castle.casl.Agent_Type_Name;
import uofa.lbirdsey.castle.casl.Agent_Types;
import uofa.lbirdsey.castle.casl.ArithmeticSigned;
import uofa.lbirdsey.castle.casl.Behavior;
import uofa.lbirdsey.castle.casl.BehaviorFeatureCall;
import uofa.lbirdsey.castle.casl.Behaviors;
import uofa.lbirdsey.castle.casl.BooleanExpression;
import uofa.lbirdsey.castle.casl.BooleanNegation;
import uofa.lbirdsey.castle.casl.BooleanType;
import uofa.lbirdsey.castle.casl.CASL_Macro_Call;
import uofa.lbirdsey.castle.casl.CASL_Macro_CountConditions;
import uofa.lbirdsey.castle.casl.CASL_Macro_EntitySetup;
import uofa.lbirdsey.castle.casl.CASL_Macro_FilterAndFunction;
import uofa.lbirdsey.castle.casl.CASL_Macro_ForEach;
import uofa.lbirdsey.castle.casl.CASL_Macro_MetricSwitch;
import uofa.lbirdsey.castle.casl.CASL_Macro_Neighbours;
import uofa.lbirdsey.castle.casl.CASL_Macro_Print;
import uofa.lbirdsey.castle.casl.CASL_Macro_Random;
import uofa.lbirdsey.castle.casl.CASL_Macro_TODO;
import uofa.lbirdsey.castle.casl.CAS_Rules;
import uofa.lbirdsey.castle.casl.Casl;
import uofa.lbirdsey.castle.casl.CaslPackage;
import uofa.lbirdsey.castle.casl.Comparison;
import uofa.lbirdsey.castle.casl.Concern;
import uofa.lbirdsey.castle.casl.DataTypeDeclaration;
import uofa.lbirdsey.castle.casl.Div;
import uofa.lbirdsey.castle.casl.EGInteraction;
import uofa.lbirdsey.castle.casl.EGInteractions;
import uofa.lbirdsey.castle.casl.ElseIfExpr;
import uofa.lbirdsey.castle.casl.End_Condition;
import uofa.lbirdsey.castle.casl.End_Conditions;
import uofa.lbirdsey.castle.casl.EnumCall;
import uofa.lbirdsey.castle.casl.EnumCallExpr;
import uofa.lbirdsey.castle.casl.Environment;
import uofa.lbirdsey.castle.casl.EnvironmentFieldReference;
import uofa.lbirdsey.castle.casl.EnvironmentInteraction;
import uofa.lbirdsey.castle.casl.EnvironmentInteractionFeatureCall;
import uofa.lbirdsey.castle.casl.EnvironmentInteractions;
import uofa.lbirdsey.castle.casl.Environment_Call;
import uofa.lbirdsey.castle.casl.Environment_Rules;
import uofa.lbirdsey.castle.casl.Environment_Type_Name;
import uofa.lbirdsey.castle.casl.Environment_Types;
import uofa.lbirdsey.castle.casl.Equals;
import uofa.lbirdsey.castle.casl.ExternalInteractionFeatureCall;
import uofa.lbirdsey.castle.casl.Feature;
import uofa.lbirdsey.castle.casl.FeatureCall;
import uofa.lbirdsey.castle.casl.FeatureCallExp;
import uofa.lbirdsey.castle.casl.Field;
import uofa.lbirdsey.castle.casl.FloatType;
import uofa.lbirdsey.castle.casl.ForEachLoop;
import uofa.lbirdsey.castle.casl.ForLoop;
import uofa.lbirdsey.castle.casl.Formula;
import uofa.lbirdsey.castle.casl.Function;
import uofa.lbirdsey.castle.casl.FunctionCall;
import uofa.lbirdsey.castle.casl.FunctionCallExpr;
import uofa.lbirdsey.castle.casl.FunctionFeatureCall;
import uofa.lbirdsey.castle.casl.FunctionParameter;
import uofa.lbirdsey.castle.casl.Functions;
import uofa.lbirdsey.castle.casl.Group;
import uofa.lbirdsey.castle.casl.GroupExternalInteraction;
import uofa.lbirdsey.castle.casl.GroupExternalInteractionFeatureCall;
import uofa.lbirdsey.castle.casl.GroupExternalInteractions;
import uofa.lbirdsey.castle.casl.GroupFieldReference;
import uofa.lbirdsey.castle.casl.GroupInternalInteraction;
import uofa.lbirdsey.castle.casl.GroupInternalInteractions;
import uofa.lbirdsey.castle.casl.GroupInternalInteractionsFeatureCall;
import uofa.lbirdsey.castle.casl.GroupSelfInternalInteractionsFeatureCall;
import uofa.lbirdsey.castle.casl.Group_Call;
import uofa.lbirdsey.castle.casl.Group_Rules;
import uofa.lbirdsey.castle.casl.Group_Type_Name;
import uofa.lbirdsey.castle.casl.Group_Types;
import uofa.lbirdsey.castle.casl.IfStatement;
import uofa.lbirdsey.castle.casl.Import;
import uofa.lbirdsey.castle.casl.IntType;
import uofa.lbirdsey.castle.casl.Interaction;
import uofa.lbirdsey.castle.casl.InteractionFeatureCall;
import uofa.lbirdsey.castle.casl.InteractionTriggerParameter;
import uofa.lbirdsey.castle.casl.Interactions;
import uofa.lbirdsey.castle.casl.MacroCall;
import uofa.lbirdsey.castle.casl.Multiplication;
import uofa.lbirdsey.castle.casl.NullType;
import uofa.lbirdsey.castle.casl.NullTypeLiteral;
import uofa.lbirdsey.castle.casl.NumberLiteral;
import uofa.lbirdsey.castle.casl.PackageDeclaration;
import uofa.lbirdsey.castle.casl.Parameters;
import uofa.lbirdsey.castle.casl.Raw_Java_Block;
import uofa.lbirdsey.castle.casl.SelfAssignedFormula;
import uofa.lbirdsey.castle.casl.SelfCall;
import uofa.lbirdsey.castle.casl.SelfCallExpr;
import uofa.lbirdsey.castle.casl.State_Block_Refs;
import uofa.lbirdsey.castle.casl.StringLiteral;
import uofa.lbirdsey.castle.casl.StringType;
import uofa.lbirdsey.castle.casl.SubSystem;
import uofa.lbirdsey.castle.casl.SubSystems;
import uofa.lbirdsey.castle.casl.Subtraction;
import uofa.lbirdsey.castle.casl.Symbol;
import uofa.lbirdsey.castle.casl.SystemCall;
import uofa.lbirdsey.castle.casl.SystemCallObj;
import uofa.lbirdsey.castle.casl.TypeRef;
import uofa.lbirdsey.castle.services.CASLGrammarAccess;

@SuppressWarnings("all")
public class CASLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CASLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CaslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CaslPackage.ADAPTIVE_PROCESS:
				sequence_AdaptiveProcess(context, (AdaptiveProcess) semanticObject); 
				return; 
			case CaslPackage.ADAPTIVE_PROCESS_FEATURE_CALL:
				sequence_AdaptiveProcessFeatureCall(context, (AdaptiveProcessFeatureCall) semanticObject); 
				return; 
			case CaslPackage.ADAPTIVE_PROCESSES:
				sequence_AdaptiveProcesses(context, (AdaptiveProcesses) semanticObject); 
				return; 
			case CaslPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case CaslPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case CaslPackage.AGENT_FIELD_REFERENCE:
				sequence_AgentFieldReference(context, (AgentFieldReference) semanticObject); 
				return; 
			case CaslPackage.AGENT_INTERACTION:
				sequence_AgentInteraction(context, (AgentInteraction) semanticObject); 
				return; 
			case CaslPackage.AGENT_INTERACTION_FEATURE_CALL:
				sequence_AgentInteractionFeatureCall(context, (AgentInteractionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.AGENT_INTERACTIONS:
				sequence_AgentInteractions(context, (AgentInteractions) semanticObject); 
				return; 
			case CaslPackage.AGENT_CALL:
				if (rule == grammarAccess.getAgent_CallRule()) {
					sequence_Agent_Call(context, (Agent_Call) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getBooleanExpressionRule()
						|| action == grammarAccess.getBooleanExpressionAccess().getBooleanExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getEqualsRule()
						|| action == grammarAccess.getEqualsAccess().getEqualsLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0_0()
						|| rule == grammarAccess.getSubtractionRule()
						|| action == grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrefixedRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Agent_Call) semanticObject); 
					return; 
				}
				else break;
			case CaslPackage.AGENT_TYPE_NAME:
				sequence_Agent_Type_Name(context, (Agent_Type_Name) semanticObject); 
				return; 
			case CaslPackage.AGENT_TYPES:
				sequence_Agent_Types(context, (Agent_Types) semanticObject); 
				return; 
			case CaslPackage.ARITHMETIC_SIGNED:
				sequence_Prefixed(context, (ArithmeticSigned) semanticObject); 
				return; 
			case CaslPackage.BEHAVIOR:
				sequence_Behavior(context, (Behavior) semanticObject); 
				return; 
			case CaslPackage.BEHAVIOR_FEATURE_CALL:
				sequence_BehaviorFeatureCall(context, (BehaviorFeatureCall) semanticObject); 
				return; 
			case CaslPackage.BEHAVIORS:
				sequence_Behaviors(context, (Behaviors) semanticObject); 
				return; 
			case CaslPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case CaslPackage.BOOLEAN_NEGATION:
				sequence_Prefixed(context, (BooleanNegation) semanticObject); 
				return; 
			case CaslPackage.BOOLEAN_TYPE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getBooleanExpressionRule()
						|| action == grammarAccess.getBooleanExpressionAccess().getBooleanExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getEqualsRule()
						|| action == grammarAccess.getEqualsAccess().getEqualsLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0_0()
						|| rule == grammarAccess.getSubtractionRule()
						|| action == grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrefixedRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (BooleanType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getPrimitiveTypeRule()
						|| rule == grammarAccess.getBooleanTypeRule()) {
					sequence_BooleanType(context, (BooleanType) semanticObject); 
					return; 
				}
				else break;
			case CaslPackage.CASL_MACRO_CALL:
				sequence_CASL_Macro_Call(context, (CASL_Macro_Call) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_COUNT_CONDITIONS:
				sequence_CASL_Macro_CountConditions(context, (CASL_Macro_CountConditions) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_ENTITY_SETUP:
				sequence_CASL_Macro_EntitySetup(context, (CASL_Macro_EntitySetup) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_FILTER_AND_FUNCTION:
				sequence_CASL_Macro_FilterAndFunction(context, (CASL_Macro_FilterAndFunction) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_FOR_EACH:
				sequence_CASL_Macro_ForEach(context, (CASL_Macro_ForEach) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_METRIC_SWITCH:
				sequence_CASL_Macro_MetricSwitch(context, (CASL_Macro_MetricSwitch) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_NEIGHBOURS:
				sequence_CASL_Macro_Neighbours(context, (CASL_Macro_Neighbours) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_PRINT:
				sequence_CASL_Macro_Print(context, (CASL_Macro_Print) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_RANDOM:
				sequence_CASL_Macro_Random(context, (CASL_Macro_Random) semanticObject); 
				return; 
			case CaslPackage.CASL_MACRO_TODO:
				sequence_CASL_Macro_TODO(context, (CASL_Macro_TODO) semanticObject); 
				return; 
			case CaslPackage.CAS_RULES:
				sequence_CAS_Rules(context, (CAS_Rules) semanticObject); 
				return; 
			case CaslPackage.CASL:
				sequence_Casl(context, (Casl) semanticObject); 
				return; 
			case CaslPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case CaslPackage.CONCERN:
				sequence_Concern(context, (Concern) semanticObject); 
				return; 
			case CaslPackage.DATA_TYPE_DECLARATION:
				sequence_DataTypeDeclaration(context, (DataTypeDeclaration) semanticObject); 
				return; 
			case CaslPackage.DIV:
				sequence_Multiplication(context, (Div) semanticObject); 
				return; 
			case CaslPackage.EG_INTERACTION:
				sequence_EGInteraction(context, (EGInteraction) semanticObject); 
				return; 
			case CaslPackage.EG_INTERACTIONS:
				sequence_EGInteractions(context, (EGInteractions) semanticObject); 
				return; 
			case CaslPackage.ELSE_IF_EXPR:
				sequence_ElseIfExpr(context, (ElseIfExpr) semanticObject); 
				return; 
			case CaslPackage.END_CONDITION:
				sequence_End_Condition(context, (End_Condition) semanticObject); 
				return; 
			case CaslPackage.END_CONDITIONS:
				sequence_End_Conditions(context, (End_Conditions) semanticObject); 
				return; 
			case CaslPackage.ENUM:
				sequence_Enum(context, (uofa.lbirdsey.castle.casl.Enum) semanticObject); 
				return; 
			case CaslPackage.ENUM_CALL:
				sequence_EnumCall(context, (EnumCall) semanticObject); 
				return; 
			case CaslPackage.ENUM_CALL_EXPR:
				sequence_Atomic(context, (EnumCallExpr) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_FIELD_REFERENCE:
				sequence_EnvironmentFieldReference(context, (EnvironmentFieldReference) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_INTERACTION:
				sequence_EnvironmentInteraction(context, (EnvironmentInteraction) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_INTERACTION_FEATURE_CALL:
				sequence_EnvironmentInteractionFeatureCall(context, (EnvironmentInteractionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_INTERACTIONS:
				sequence_EnvironmentInteractions(context, (EnvironmentInteractions) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_CALL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getBooleanExpressionRule()
						|| action == grammarAccess.getBooleanExpressionAccess().getBooleanExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getEqualsRule()
						|| action == grammarAccess.getEqualsAccess().getEqualsLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0_0()
						|| rule == grammarAccess.getSubtractionRule()
						|| action == grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrefixedRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Environment_Call) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnvironment_CallRule()) {
					sequence_Environment_Call(context, (Environment_Call) semanticObject); 
					return; 
				}
				else break;
			case CaslPackage.ENVIRONMENT_RULES:
				sequence_Environment_Rules(context, (Environment_Rules) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_TYPE_NAME:
				sequence_Environment_Type_Name(context, (Environment_Type_Name) semanticObject); 
				return; 
			case CaslPackage.ENVIRONMENT_TYPES:
				sequence_Environment_Types(context, (Environment_Types) semanticObject); 
				return; 
			case CaslPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case CaslPackage.EXTERNAL_INTERACTION_FEATURE_CALL:
				sequence_ExternalInteractionFeatureCall(context, (ExternalInteractionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case CaslPackage.FEATURE_CALL:
				sequence_FeatureCall(context, (FeatureCall) semanticObject); 
				return; 
			case CaslPackage.FEATURE_CALL_EXP:
				sequence_Atomic(context, (FeatureCallExp) semanticObject); 
				return; 
			case CaslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case CaslPackage.FLOAT_TYPE:
				sequence_FloatType(context, (FloatType) semanticObject); 
				return; 
			case CaslPackage.FOR_EACH_LOOP:
				sequence_ForEachLoop(context, (ForEachLoop) semanticObject); 
				return; 
			case CaslPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case CaslPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case CaslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CaslPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case CaslPackage.FUNCTION_CALL_EXPR:
				sequence_Atomic(context, (FunctionCallExpr) semanticObject); 
				return; 
			case CaslPackage.FUNCTION_FEATURE_CALL:
				sequence_FunctionFeatureCall(context, (FunctionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.FUNCTION_PARAMETER:
				sequence_FunctionParameter(context, (FunctionParameter) semanticObject); 
				return; 
			case CaslPackage.FUNCTIONS:
				sequence_Functions(context, (Functions) semanticObject); 
				return; 
			case CaslPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case CaslPackage.GROUP_EXTERNAL_INTERACTION:
				sequence_GroupExternalInteraction(context, (GroupExternalInteraction) semanticObject); 
				return; 
			case CaslPackage.GROUP_EXTERNAL_INTERACTION_FEATURE_CALL:
				sequence_GroupExternalInteractionFeatureCall(context, (GroupExternalInteractionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.GROUP_EXTERNAL_INTERACTIONS:
				sequence_GroupExternalInteractions(context, (GroupExternalInteractions) semanticObject); 
				return; 
			case CaslPackage.GROUP_FIELD_REFERENCE:
				sequence_GroupFieldReference(context, (GroupFieldReference) semanticObject); 
				return; 
			case CaslPackage.GROUP_INTERNAL_INTERACTION:
				sequence_GroupInternalInteraction(context, (GroupInternalInteraction) semanticObject); 
				return; 
			case CaslPackage.GROUP_INTERNAL_INTERACTIONS:
				sequence_GroupInternalInteractions(context, (GroupInternalInteractions) semanticObject); 
				return; 
			case CaslPackage.GROUP_INTERNAL_INTERACTIONS_FEATURE_CALL:
				sequence_GroupInternalInteractionsFeatureCall(context, (GroupInternalInteractionsFeatureCall) semanticObject); 
				return; 
			case CaslPackage.GROUP_SELF_INTERNAL_INTERACTIONS_FEATURE_CALL:
				sequence_GroupSelfInternalInteractionsFeatureCall(context, (GroupSelfInternalInteractionsFeatureCall) semanticObject); 
				return; 
			case CaslPackage.GROUP_CALL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getBooleanExpressionRule()
						|| action == grammarAccess.getBooleanExpressionAccess().getBooleanExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getEqualsRule()
						|| action == grammarAccess.getEqualsAccess().getEqualsLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0_0()
						|| rule == grammarAccess.getSubtractionRule()
						|| action == grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0()
						|| action == grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrefixedRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Group_Call) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGroup_CallRule()) {
					sequence_Group_Call(context, (Group_Call) semanticObject); 
					return; 
				}
				else break;
			case CaslPackage.GROUP_RULES:
				sequence_Group_Rules(context, (Group_Rules) semanticObject); 
				return; 
			case CaslPackage.GROUP_TYPE_NAME:
				sequence_Group_Type_Name(context, (Group_Type_Name) semanticObject); 
				return; 
			case CaslPackage.GROUP_TYPES:
				sequence_Group_Types(context, (Group_Types) semanticObject); 
				return; 
			case CaslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case CaslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case CaslPackage.INT_TYPE:
				sequence_IntType(context, (IntType) semanticObject); 
				return; 
			case CaslPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case CaslPackage.INTERACTION_FEATURE_CALL:
				sequence_InteractionFeatureCall(context, (InteractionFeatureCall) semanticObject); 
				return; 
			case CaslPackage.INTERACTION_TRIGGER_PARAMETER:
				sequence_InteractionTriggerParameter(context, (InteractionTriggerParameter) semanticObject); 
				return; 
			case CaslPackage.INTERACTIONS:
				sequence_Interactions(context, (Interactions) semanticObject); 
				return; 
			case CaslPackage.MACRO_CALL:
				sequence_Atomic(context, (MacroCall) semanticObject); 
				return; 
			case CaslPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case CaslPackage.NULL_TYPE:
				sequence_NullType(context, (NullType) semanticObject); 
				return; 
			case CaslPackage.NULL_TYPE_LITERAL:
				sequence_Atomic(context, (NullTypeLiteral) semanticObject); 
				return; 
			case CaslPackage.NUMBER_LITERAL:
				sequence_Atomic(context, (NumberLiteral) semanticObject); 
				return; 
			case CaslPackage.OBJECT:
				sequence_Object(context, (uofa.lbirdsey.castle.casl.Object) semanticObject); 
				return; 
			case CaslPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case CaslPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case CaslPackage.RAW_JAVA_BLOCK:
				sequence_Raw_Java_Block(context, (Raw_Java_Block) semanticObject); 
				return; 
			case CaslPackage.SELF_ASSIGNED_FORMULA:
				sequence_SelfAssignedFormula(context, (SelfAssignedFormula) semanticObject); 
				return; 
			case CaslPackage.SELF_CALL:
				sequence_SelfCall(context, (SelfCall) semanticObject); 
				return; 
			case CaslPackage.SELF_CALL_EXPR:
				sequence_Atomic(context, (SelfCallExpr) semanticObject); 
				return; 
			case CaslPackage.STATE_BLOCK_REFS:
				sequence_State_Block_Refs(context, (State_Block_Refs) semanticObject); 
				return; 
			case CaslPackage.STRING_LITERAL:
				sequence_Atomic(context, (StringLiteral) semanticObject); 
				return; 
			case CaslPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case CaslPackage.SUB_SYSTEM:
				sequence_SubSystem(context, (SubSystem) semanticObject); 
				return; 
			case CaslPackage.SUB_SYSTEMS:
				sequence_SubSystems(context, (SubSystems) semanticObject); 
				return; 
			case CaslPackage.SUBTRACTION:
				sequence_Subtraction(context, (Subtraction) semanticObject); 
				return; 
			case CaslPackage.SYMBOL:
				if (rule == grammarAccess.getEnum_FieldRule()) {
					sequence_Enum_Field(context, (Symbol) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForEachAccessRule()) {
					sequence_ForEachAccess(context, (Symbol) semanticObject); 
					return; 
				}
				else break;
			case CaslPackage.SYSTEM:
				sequence_System(context, (uofa.lbirdsey.castle.casl.System) semanticObject); 
				return; 
			case CaslPackage.SYSTEM_CALL:
				sequence_SystemCall(context, (SystemCall) semanticObject); 
				return; 
			case CaslPackage.SYSTEM_CALL_OBJ:
				sequence_Atomic(context, (SystemCallObj) semanticObject); 
				return; 
			case CaslPackage.TYPE_REF:
				sequence_Atomic(context, (TypeRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdaptiveProcessFeatureCall returns AdaptiveProcessFeatureCall
	 *
	 * Constraint:
	 *     (process=[AdaptiveProcess|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_AdaptiveProcessFeatureCall(ISerializationContext context, AdaptiveProcessFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns AdaptiveProcess
	 *     AdaptiveProcess returns AdaptiveProcess
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         adaptation_type=AdaptationType 
	 *         adaptationDelay=AdaptationDelay 
	 *         functionParameters+=FunctionParameter* 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_AdaptiveProcess(ISerializationContext context, AdaptiveProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdaptiveProcesses returns AdaptiveProcesses
	 *
	 * Constraint:
	 *     adaptation+=AdaptiveProcess*
	 */
	protected void sequence_AdaptiveProcesses(ISerializationContext context, AdaptiveProcesses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Addition
	 *     BooleanExpression returns Addition
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Addition
	 *     Equals returns Addition
	 *     Equals.Equals_1_0_0 returns Addition
	 *     Comparison returns Addition
	 *     Comparison.Comparison_1_0_0 returns Addition
	 *     Subtraction returns Addition
	 *     Subtraction.Subtraction_1_0 returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0_0_0 returns Addition
	 *     Multiplication.Div_1_0_1_0 returns Addition
	 *     Prefixed returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0 op='+' right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAddition_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAddition_Left()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAddition_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAddition_Op()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAddition_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAddition_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getOpPlusSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AgentFieldReference returns AgentFieldReference
	 *
	 * Constraint:
	 *     (agent=[Agent|ID] name=ID assignment=Expression?)
	 */
	protected void sequence_AgentFieldReference(ISerializationContext context, AgentFieldReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AgentInteractionFeatureCall returns AgentInteractionFeatureCall
	 *
	 * Constraint:
	 *     (agt=[Symbol|ID] process=[AgentInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_AgentInteractionFeatureCall(ISerializationContext context, AgentInteractionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AgentInteraction returns AgentInteraction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         interaction_type=InteractionType 
	 *         trigger_type=InteractionTriggerTypes 
	 *         triggerParam=InteractionTriggerParameter? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_AgentInteraction(ISerializationContext context, AgentInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AgentInteractions returns AgentInteractions
	 *
	 * Constraint:
	 *     interactions+=AgentInteraction*
	 */
	protected void sequence_AgentInteractions(ISerializationContext context, AgentInteractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Agent
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         desc=STRING 
	 *         agent_parameters=Parameters 
	 *         agent_functions=Functions 
	 *         agent_behaviors=Behaviors 
	 *         agent_interactions=AgentInteractions 
	 *         agent_adaptation=AdaptiveProcesses 
	 *         agent_subSystems=SubSystems
	 *     )
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_parameters()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_parameters()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_functions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_functions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_behaviors()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_behaviors()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_interactions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_interactions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_adaptation()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_adaptation()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_subSystems()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Agent_subSystems()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAgentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAgentAccess().getDescSTRINGTerminalRuleCall_5_0(), semanticObject.getDesc());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_parametersParametersParserRuleCall_7_0(), semanticObject.getAgent_parameters());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_functionsFunctionsParserRuleCall_8_0(), semanticObject.getAgent_functions());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_behaviorsBehaviorsParserRuleCall_9_0(), semanticObject.getAgent_behaviors());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_interactionsAgentInteractionsParserRuleCall_10_0(), semanticObject.getAgent_interactions());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_adaptationAdaptiveProcessesParserRuleCall_11_0(), semanticObject.getAgent_adaptation());
		feeder.accept(grammarAccess.getAgentAccess().getAgent_subSystemsSubSystemsParserRuleCall_12_0(), semanticObject.getAgent_subSystems());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Agent_Call returns Agent_Call
	 *
	 * Constraint:
	 *     (agent=[Agent|ID] qnc=QualifiedNameCall?)
	 */
	protected void sequence_Agent_Call(ISerializationContext context, Agent_Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Agent_Type_Name returns Agent_Type_Name
	 *
	 * Constraint:
	 *     agent_type_name=QualifiedName
	 */
	protected void sequence_Agent_Type_Name(ISerializationContext context, Agent_Type_Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Type_Name_Agent_type_name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Type_Name_Agent_type_name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAgent_Type_NameAccess().getAgent_type_nameQualifiedNameParserRuleCall_1_0(), semanticObject.getAgent_type_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Agent_Types returns Agent_Types
	 *
	 * Constraint:
	 *     (agent_types+=Agent_Type_Name agent_types+=Agent_Type_Name*)
	 */
	protected void sequence_Agent_Types(ISerializationContext context, Agent_Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Agent_Call
	 *     BooleanExpression returns Agent_Call
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Agent_Call
	 *     Equals returns Agent_Call
	 *     Equals.Equals_1_0_0 returns Agent_Call
	 *     Comparison returns Agent_Call
	 *     Comparison.Comparison_1_0_0 returns Agent_Call
	 *     Subtraction returns Agent_Call
	 *     Subtraction.Subtraction_1_0 returns Agent_Call
	 *     Addition returns Agent_Call
	 *     Addition.Addition_1_0 returns Agent_Call
	 *     Multiplication returns Agent_Call
	 *     Multiplication.Multiplication_1_0_0_0 returns Agent_Call
	 *     Multiplication.Div_1_0_1_0 returns Agent_Call
	 *     Prefixed returns Agent_Call
	 *     Atomic returns Agent_Call
	 *
	 * Constraint:
	 *     agentCall=Agent_Call
	 */
	protected void sequence_Atomic(ISerializationContext context, Agent_Call semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getAgent_Call_AgentCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getAgent_Call_AgentCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getAgentCallAgent_CallParserRuleCall_12_1_0(), semanticObject.getAgentCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanType
	 *     BooleanExpression returns BooleanType
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanType
	 *     Equals returns BooleanType
	 *     Equals.Equals_1_0_0 returns BooleanType
	 *     Comparison returns BooleanType
	 *     Comparison.Comparison_1_0_0 returns BooleanType
	 *     Subtraction returns BooleanType
	 *     Subtraction.Subtraction_1_0 returns BooleanType
	 *     Addition returns BooleanType
	 *     Addition.Addition_1_0 returns BooleanType
	 *     Multiplication returns BooleanType
	 *     Multiplication.Multiplication_1_0_0_0 returns BooleanType
	 *     Multiplication.Div_1_0_1_0 returns BooleanType
	 *     Prefixed returns BooleanType
	 *     Atomic returns BooleanType
	 *
	 * Constraint:
	 *     bool=BooleanValue
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getBooleanType_Bool()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getBooleanType_Bool()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getBoolBooleanValueParserRuleCall_3_1_0(), semanticObject.isBool());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EnumCallExpr
	 *     BooleanExpression returns EnumCallExpr
	 *     BooleanExpression.BooleanExpression_1_0_0 returns EnumCallExpr
	 *     Equals returns EnumCallExpr
	 *     Equals.Equals_1_0_0 returns EnumCallExpr
	 *     Comparison returns EnumCallExpr
	 *     Comparison.Comparison_1_0_0 returns EnumCallExpr
	 *     Subtraction returns EnumCallExpr
	 *     Subtraction.Subtraction_1_0 returns EnumCallExpr
	 *     Addition returns EnumCallExpr
	 *     Addition.Addition_1_0 returns EnumCallExpr
	 *     Multiplication returns EnumCallExpr
	 *     Multiplication.Multiplication_1_0_0_0 returns EnumCallExpr
	 *     Multiplication.Div_1_0_1_0 returns EnumCallExpr
	 *     Prefixed returns EnumCallExpr
	 *     Atomic returns EnumCallExpr
	 *
	 * Constraint:
	 *     enumCall=EnumCall
	 */
	protected void sequence_Atomic(ISerializationContext context, EnumCallExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnumCallExpr_EnumCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnumCallExpr_EnumCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getEnumCallEnumCallParserRuleCall_10_1_0(), semanticObject.getEnumCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Environment_Call
	 *     BooleanExpression returns Environment_Call
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Environment_Call
	 *     Equals returns Environment_Call
	 *     Equals.Equals_1_0_0 returns Environment_Call
	 *     Comparison returns Environment_Call
	 *     Comparison.Comparison_1_0_0 returns Environment_Call
	 *     Subtraction returns Environment_Call
	 *     Subtraction.Subtraction_1_0 returns Environment_Call
	 *     Addition returns Environment_Call
	 *     Addition.Addition_1_0 returns Environment_Call
	 *     Multiplication returns Environment_Call
	 *     Multiplication.Multiplication_1_0_0_0 returns Environment_Call
	 *     Multiplication.Div_1_0_1_0 returns Environment_Call
	 *     Prefixed returns Environment_Call
	 *     Atomic returns Environment_Call
	 *
	 * Constraint:
	 *     environmentCall=Environment_Call
	 */
	protected void sequence_Atomic(ISerializationContext context, Environment_Call semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Call_EnvironmentCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Call_EnvironmentCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getEnvironmentCallEnvironment_CallParserRuleCall_13_1_0(), semanticObject.getEnvironmentCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FeatureCallExp
	 *     BooleanExpression returns FeatureCallExp
	 *     BooleanExpression.BooleanExpression_1_0_0 returns FeatureCallExp
	 *     Equals returns FeatureCallExp
	 *     Equals.Equals_1_0_0 returns FeatureCallExp
	 *     Comparison returns FeatureCallExp
	 *     Comparison.Comparison_1_0_0 returns FeatureCallExp
	 *     Subtraction returns FeatureCallExp
	 *     Subtraction.Subtraction_1_0 returns FeatureCallExp
	 *     Addition returns FeatureCallExp
	 *     Addition.Addition_1_0 returns FeatureCallExp
	 *     Multiplication returns FeatureCallExp
	 *     Multiplication.Multiplication_1_0_0_0 returns FeatureCallExp
	 *     Multiplication.Div_1_0_1_0 returns FeatureCallExp
	 *     Prefixed returns FeatureCallExp
	 *     Atomic returns FeatureCallExp
	 *
	 * Constraint:
	 *     func=FeatureCall
	 */
	protected void sequence_Atomic(ISerializationContext context, FeatureCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getFeatureCallExp_Func()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getFeatureCallExp_Func()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getFuncFeatureCallParserRuleCall_6_1_0(), semanticObject.getFunc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCallExpr
	 *     BooleanExpression returns FunctionCallExpr
	 *     BooleanExpression.BooleanExpression_1_0_0 returns FunctionCallExpr
	 *     Equals returns FunctionCallExpr
	 *     Equals.Equals_1_0_0 returns FunctionCallExpr
	 *     Comparison returns FunctionCallExpr
	 *     Comparison.Comparison_1_0_0 returns FunctionCallExpr
	 *     Subtraction returns FunctionCallExpr
	 *     Subtraction.Subtraction_1_0 returns FunctionCallExpr
	 *     Addition returns FunctionCallExpr
	 *     Addition.Addition_1_0 returns FunctionCallExpr
	 *     Multiplication returns FunctionCallExpr
	 *     Multiplication.Multiplication_1_0_0_0 returns FunctionCallExpr
	 *     Multiplication.Div_1_0_1_0 returns FunctionCallExpr
	 *     Prefixed returns FunctionCallExpr
	 *     Atomic returns FunctionCallExpr
	 *
	 * Constraint:
	 *     funcCall=FunctionCall
	 */
	protected void sequence_Atomic(ISerializationContext context, FunctionCallExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getFunctionCallExpr_FuncCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getFunctionCallExpr_FuncCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getFuncCallFunctionCallParserRuleCall_9_1_0(), semanticObject.getFuncCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Group_Call
	 *     BooleanExpression returns Group_Call
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Group_Call
	 *     Equals returns Group_Call
	 *     Equals.Equals_1_0_0 returns Group_Call
	 *     Comparison returns Group_Call
	 *     Comparison.Comparison_1_0_0 returns Group_Call
	 *     Subtraction returns Group_Call
	 *     Subtraction.Subtraction_1_0 returns Group_Call
	 *     Addition returns Group_Call
	 *     Addition.Addition_1_0 returns Group_Call
	 *     Multiplication returns Group_Call
	 *     Multiplication.Multiplication_1_0_0_0 returns Group_Call
	 *     Multiplication.Div_1_0_1_0 returns Group_Call
	 *     Prefixed returns Group_Call
	 *     Atomic returns Group_Call
	 *
	 * Constraint:
	 *     groupCall=Group_Call
	 */
	protected void sequence_Atomic(ISerializationContext context, Group_Call semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Call_GroupCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Call_GroupCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getGroupCallGroup_CallParserRuleCall_11_1_0(), semanticObject.getGroupCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MacroCall
	 *     BooleanExpression returns MacroCall
	 *     BooleanExpression.BooleanExpression_1_0_0 returns MacroCall
	 *     Equals returns MacroCall
	 *     Equals.Equals_1_0_0 returns MacroCall
	 *     Comparison returns MacroCall
	 *     Comparison.Comparison_1_0_0 returns MacroCall
	 *     Subtraction returns MacroCall
	 *     Subtraction.Subtraction_1_0 returns MacroCall
	 *     Addition returns MacroCall
	 *     Addition.Addition_1_0 returns MacroCall
	 *     Multiplication returns MacroCall
	 *     Multiplication.Multiplication_1_0_0_0 returns MacroCall
	 *     Multiplication.Div_1_0_1_0 returns MacroCall
	 *     Prefixed returns MacroCall
	 *     Atomic returns MacroCall
	 *
	 * Constraint:
	 *     macroCall=CASL_Macro_Call
	 */
	protected void sequence_Atomic(ISerializationContext context, MacroCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getMacroCall_MacroCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getMacroCall_MacroCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getMacroCallCASL_Macro_CallParserRuleCall_8_1_0(), semanticObject.getMacroCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullTypeLiteral
	 *     BooleanExpression returns NullTypeLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns NullTypeLiteral
	 *     Equals returns NullTypeLiteral
	 *     Equals.Equals_1_0_0 returns NullTypeLiteral
	 *     Comparison returns NullTypeLiteral
	 *     Comparison.Comparison_1_0_0 returns NullTypeLiteral
	 *     Subtraction returns NullTypeLiteral
	 *     Subtraction.Subtraction_1_0 returns NullTypeLiteral
	 *     Addition returns NullTypeLiteral
	 *     Addition.Addition_1_0 returns NullTypeLiteral
	 *     Multiplication returns NullTypeLiteral
	 *     Multiplication.Multiplication_1_0_0_0 returns NullTypeLiteral
	 *     Multiplication.Div_1_0_1_0 returns NullTypeLiteral
	 *     Prefixed returns NullTypeLiteral
	 *     Atomic returns NullTypeLiteral
	 *
	 * Constraint:
	 *     nulltype=NullType
	 */
	protected void sequence_Atomic(ISerializationContext context, NullTypeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getNullTypeLiteral_Nulltype()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getNullTypeLiteral_Nulltype()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getNulltypeNullTypeParserRuleCall_2_1_0(), semanticObject.getNulltype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     BooleanExpression returns NumberLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns NumberLiteral
	 *     Equals returns NumberLiteral
	 *     Equals.Equals_1_0_0 returns NumberLiteral
	 *     Comparison returns NumberLiteral
	 *     Comparison.Comparison_1_0_0 returns NumberLiteral
	 *     Subtraction returns NumberLiteral
	 *     Subtraction.Subtraction_1_0 returns NumberLiteral
	 *     Addition returns NumberLiteral
	 *     Addition.Addition_1_0 returns NumberLiteral
	 *     Multiplication returns NumberLiteral
	 *     Multiplication.Multiplication_1_0_0_0 returns NumberLiteral
	 *     Multiplication.Div_1_0_1_0 returns NumberLiteral
	 *     Prefixed returns NumberLiteral
	 *     Atomic returns NumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_Atomic(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getNumberLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getNumberLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueNUMBERTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SelfCallExpr
	 *     BooleanExpression returns SelfCallExpr
	 *     BooleanExpression.BooleanExpression_1_0_0 returns SelfCallExpr
	 *     Equals returns SelfCallExpr
	 *     Equals.Equals_1_0_0 returns SelfCallExpr
	 *     Comparison returns SelfCallExpr
	 *     Comparison.Comparison_1_0_0 returns SelfCallExpr
	 *     Subtraction returns SelfCallExpr
	 *     Subtraction.Subtraction_1_0 returns SelfCallExpr
	 *     Addition returns SelfCallExpr
	 *     Addition.Addition_1_0 returns SelfCallExpr
	 *     Multiplication returns SelfCallExpr
	 *     Multiplication.Multiplication_1_0_0_0 returns SelfCallExpr
	 *     Multiplication.Div_1_0_1_0 returns SelfCallExpr
	 *     Prefixed returns SelfCallExpr
	 *     Atomic returns SelfCallExpr
	 *
	 * Constraint:
	 *     selfCall=SelfCall
	 */
	protected void sequence_Atomic(ISerializationContext context, SelfCallExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSelfCallExpr_SelfCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSelfCallExpr_SelfCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getSelfCallSelfCallParserRuleCall_7_1_0(), semanticObject.getSelfCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     BooleanExpression returns StringLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns StringLiteral
	 *     Equals returns StringLiteral
	 *     Equals.Equals_1_0_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0_0 returns StringLiteral
	 *     Subtraction returns StringLiteral
	 *     Subtraction.Subtraction_1_0 returns StringLiteral
	 *     Addition returns StringLiteral
	 *     Addition.Addition_1_0 returns StringLiteral
	 *     Multiplication returns StringLiteral
	 *     Multiplication.Multiplication_1_0_0_0 returns StringLiteral
	 *     Multiplication.Div_1_0_1_0 returns StringLiteral
	 *     Prefixed returns StringLiteral
	 *     Atomic returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getStringLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getStringLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SystemCallObj
	 *     BooleanExpression returns SystemCallObj
	 *     BooleanExpression.BooleanExpression_1_0_0 returns SystemCallObj
	 *     Equals returns SystemCallObj
	 *     Equals.Equals_1_0_0 returns SystemCallObj
	 *     Comparison returns SystemCallObj
	 *     Comparison.Comparison_1_0_0 returns SystemCallObj
	 *     Subtraction returns SystemCallObj
	 *     Subtraction.Subtraction_1_0 returns SystemCallObj
	 *     Addition returns SystemCallObj
	 *     Addition.Addition_1_0 returns SystemCallObj
	 *     Multiplication returns SystemCallObj
	 *     Multiplication.Multiplication_1_0_0_0 returns SystemCallObj
	 *     Multiplication.Div_1_0_1_0 returns SystemCallObj
	 *     Prefixed returns SystemCallObj
	 *     Atomic returns SystemCallObj
	 *
	 * Constraint:
	 *     sysCall=SystemCall
	 */
	protected void sequence_Atomic(ISerializationContext context, SystemCallObj semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystemCallObj_SysCall()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystemCallObj_SysCall()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getSysCallSystemCallParserRuleCall_5_1_0(), semanticObject.getSysCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TypeRef
	 *     BooleanExpression returns TypeRef
	 *     BooleanExpression.BooleanExpression_1_0_0 returns TypeRef
	 *     Equals returns TypeRef
	 *     Equals.Equals_1_0_0 returns TypeRef
	 *     Comparison returns TypeRef
	 *     Comparison.Comparison_1_0_0 returns TypeRef
	 *     Subtraction returns TypeRef
	 *     Subtraction.Subtraction_1_0 returns TypeRef
	 *     Addition returns TypeRef
	 *     Addition.Addition_1_0 returns TypeRef
	 *     Multiplication returns TypeRef
	 *     Multiplication.Multiplication_1_0_0_0 returns TypeRef
	 *     Multiplication.Div_1_0_1_0 returns TypeRef
	 *     Prefixed returns TypeRef
	 *     Atomic returns TypeRef
	 *
	 * Constraint:
	 *     type=[Symbol|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, TypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getTypeRef_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getTypeRef_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTypeSymbolIDTerminalRuleCall_4_1_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getTypeRef_Type(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorFeatureCall returns BehaviorFeatureCall
	 *
	 * Constraint:
	 *     (process=[Behavior|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_BehaviorFeatureCall(ISerializationContext context, BehaviorFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns Behavior
	 *     Behavior returns Behavior
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         behavior_type=BehaviorType 
	 *         behavior_reaction_time=BehaviorReactionTime 
	 *         reaction_time_parm=Expression? 
	 *         functionParameters+=FunctionParameter? 
	 *         functionParameters+=FunctionParameter* 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_Behavior(ISerializationContext context, Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Behaviors returns Behaviors
	 *
	 * Constraint:
	 *     behaviors+=Behavior*
	 */
	protected void sequence_Behaviors(ISerializationContext context, Behaviors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanExpression
	 *     Equals returns BooleanExpression
	 *     Equals.Equals_1_0_0 returns BooleanExpression
	 *     Comparison returns BooleanExpression
	 *     Comparison.Comparison_1_0_0 returns BooleanExpression
	 *     Subtraction returns BooleanExpression
	 *     Subtraction.Subtraction_1_0 returns BooleanExpression
	 *     Addition returns BooleanExpression
	 *     Addition.Addition_1_0 returns BooleanExpression
	 *     Multiplication returns BooleanExpression
	 *     Multiplication.Multiplication_1_0_0_0 returns BooleanExpression
	 *     Multiplication.Div_1_0_1_0 returns BooleanExpression
	 *     Prefixed returns BooleanExpression
	 *
	 * Constraint:
	 *     (left=BooleanExpression_BooleanExpression_1_0_0 (op='||' | op='&&') right=Equals)
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BooleanType
	 *     PrimitiveType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     name='bool'
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getNameBoolKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro_Call returns CASL_Macro_Call
	 *
	 * Constraint:
	 *     macro=CASL_Macro
	 */
	protected void sequence_CASL_Macro_Call(ISerializationContext context, CASL_Macro_Call semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Call_Macro()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Call_Macro()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_CallAccess().getMacroCASL_MacroParserRuleCall_1_0(), semanticObject.getMacro());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_CountConditions
	 *     CASL_Macro_CountConditions returns CASL_Macro_CountConditions
	 *
	 * Constraint:
	 *     (sym=[Symbol|ID] cond=Expression)
	 */
	protected void sequence_CASL_Macro_CountConditions(ISerializationContext context, CASL_Macro_CountConditions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_CountConditions_Sym()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_CountConditions_Sym()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_CountConditions_Cond()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_CountConditions_Cond()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_CountConditionsAccess().getSymSymbolIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getCASL_Macro_CountConditions_Sym(), false));
		feeder.accept(grammarAccess.getCASL_Macro_CountConditionsAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_EntitySetup
	 *     CASL_Macro_EntitySetup returns CASL_Macro_EntitySetup
	 *
	 * Constraint:
	 *     (initNum=Expression ent=[Entity|ID] params+=Expression)
	 */
	protected void sequence_CASL_Macro_EntitySetup(ISerializationContext context, CASL_Macro_EntitySetup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_FilterAndFunction
	 *     CASL_Macro_FilterAndFunction returns CASL_Macro_FilterAndFunction
	 *
	 * Constraint:
	 *     (sym=[Symbol|ID] cond=Expression misc=ID)
	 */
	protected void sequence_CASL_Macro_FilterAndFunction(ISerializationContext context, CASL_Macro_FilterAndFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Sym()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Sym()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Cond()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Cond()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Misc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Misc()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_FilterAndFunctionAccess().getSymSymbolIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getCASL_Macro_FilterAndFunction_Sym(), false));
		feeder.accept(grammarAccess.getCASL_Macro_FilterAndFunctionAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getCASL_Macro_FilterAndFunctionAccess().getMiscIDTerminalRuleCall_5_0(), semanticObject.getMisc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_ForEach
	 *     CASL_Macro_ForEach returns CASL_Macro_ForEach
	 *
	 * Constraint:
	 *     (sym=[Symbol|ID] expr=Expression)
	 */
	protected void sequence_CASL_Macro_ForEach(ISerializationContext context, CASL_Macro_ForEach semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_ForEach_Sym()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_ForEach_Sym()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_ForEach_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_ForEach_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_ForEachAccess().getSymSymbolIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getCASL_Macro_ForEach_Sym(), false));
		feeder.accept(grammarAccess.getCASL_Macro_ForEachAccess().getExprExpressionParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_MetricSwitch
	 *     CASL_Macro_MetricSwitch returns CASL_Macro_MetricSwitch
	 *
	 * Constraint:
	 *     sw=BooleanValue
	 */
	protected void sequence_CASL_Macro_MetricSwitch(ISerializationContext context, CASL_Macro_MetricSwitch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_MetricSwitch_Sw()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_MetricSwitch_Sw()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_MetricSwitchAccess().getSwBooleanValueParserRuleCall_1_0(), semanticObject.isSw());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_Neighbours
	 *     CASL_Macro_Neighbours returns CASL_Macro_Neighbours
	 *
	 * Constraint:
	 *     (worldType=WorldType searchType=[Entity|ID] dist=NUMBER)
	 */
	protected void sequence_CASL_Macro_Neighbours(ISerializationContext context, CASL_Macro_Neighbours semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_WorldType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_WorldType()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_SearchType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_SearchType()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_Dist()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_Dist()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_NeighboursAccess().getWorldTypeWorldTypeEnumRuleCall_0_0(), semanticObject.getWorldType());
		feeder.accept(grammarAccess.getCASL_Macro_NeighboursAccess().getSearchTypeEntityIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getCASL_Macro_Neighbours_SearchType(), false));
		feeder.accept(grammarAccess.getCASL_Macro_NeighboursAccess().getDistNUMBERTerminalRuleCall_4_0(), semanticObject.getDist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_Print
	 *     CASL_Macro_Print returns CASL_Macro_Print
	 *
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_CASL_Macro_Print(ISerializationContext context, CASL_Macro_Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Print_Str()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_Print_Str()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_PrintAccess().getStrSTRINGTerminalRuleCall_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_Random
	 *     CASL_Macro_Random returns CASL_Macro_Random
	 *
	 * Constraint:
	 *     (type=numType low=Expression high=Expression?)
	 */
	protected void sequence_CASL_Macro_Random(ISerializationContext context, CASL_Macro_Random semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CASL_Macro returns CASL_Macro_TODO
	 *     CASL_Macro_TODO returns CASL_Macro_TODO
	 *
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_CASL_Macro_TODO(ISerializationContext context, CASL_Macro_TODO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_TODO_Str()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getCASL_Macro_TODO_Str()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCASL_Macro_TODOAccess().getStrSTRINGTerminalRuleCall_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CAS_Rules returns CAS_Rules
	 *
	 * Constraint:
	 *     (cas_rule=CAS_Rule_Types cas_check=CAS_Inspection_Level exceptions+=CAS_Rule_Exception* semanticgroups=CAS_Semantic_Group_Switch)
	 */
	protected void sequence_CAS_Rules(ISerializationContext context, CAS_Rules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Casl returns Casl
	 *
	 * Constraint:
	 *     (
	 *         (((packageElements+=AbstractElement+ system=System) | system=System)? (agents+=Agent | environments+=Environment | groups+=Group)+) | 
	 *         (agents+=Agent | environments+=Environment | groups+=Group)+
	 *     )?
	 */
	protected void sequence_Casl(ISerializationContext context, Casl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     BooleanExpression returns Comparison
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Comparison
	 *     Equals returns Comparison
	 *     Equals.Equals_1_0_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0_0 returns Comparison
	 *     Subtraction returns Comparison
	 *     Subtraction.Subtraction_1_0 returns Comparison
	 *     Addition returns Comparison
	 *     Addition.Addition_1_0 returns Comparison
	 *     Multiplication returns Comparison
	 *     Multiplication.Multiplication_1_0_0_0 returns Comparison
	 *     Multiplication.Div_1_0_1_0 returns Comparison
	 *     Prefixed returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0_0 (op='<' | op='>' | op='<=' | op='>=') right=Subtraction)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concern returns Concern
	 *
	 * Constraint:
	 *     (name=ID desc=STRING stateFields+=State_Block_Refs stateFields+=State_Block_Refs*)
	 */
	protected void sequence_Concern(ISerializationContext context, Concern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDeclaration returns DataTypeDeclaration
	 *
	 * Constraint:
	 *     (
	 *         initInclude='*'? 
	 *         (
	 *             type=PrimitiveType | 
	 *             (
	 *                 obj=[NonPrimitiveType|ID] 
	 *                 (useObj=[NonPrimitiveType|ID] | useType=PrimitiveType | useGroup=[Group|ID] | useAgent=[Agent|ID] | useEnv=[Environment|ID])?
	 *             )
	 *         ) 
	 *         name=ID 
	 *         expr=Expression?
	 *     )
	 */
	protected void sequence_DataTypeDeclaration(ISerializationContext context, DataTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EGInteraction returns EGInteraction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         layoutType=LayoutType 
	 *         trigger_type=InteractionTriggerTypes 
	 *         triggerParam=InteractionTriggerParameter? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_EGInteraction(ISerializationContext context, EGInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EGInteractions returns EGInteractions
	 *
	 * Constraint:
	 *     interactions+=EGInteraction*
	 */
	protected void sequence_EGInteractions(ISerializationContext context, EGInteractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfExpr returns ElseIfExpr
	 *
	 * Constraint:
	 *     (elseifCond=Expression (elseifthen+=Expression | elseifthen+=Formula | elseifthen+=SelfAssignedFormula | elseifthen+=Field)*)
	 */
	protected void sequence_ElseIfExpr(ISerializationContext context, ElseIfExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     End_Condition returns End_Condition
	 *
	 * Constraint:
	 *     (endType=EndConditionTypes name=ID)
	 */
	protected void sequence_End_Condition(ISerializationContext context, End_Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnd_Condition_EndType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnd_Condition_EndType()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnd_Condition_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnd_Condition_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnd_ConditionAccess().getEndTypeEndConditionTypesEnumRuleCall_1_0(), semanticObject.getEndType());
		feeder.accept(grammarAccess.getEnd_ConditionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     End_Conditions returns End_Conditions
	 *
	 * Constraint:
	 *     end_conditions+=End_Condition+
	 */
	protected void sequence_End_Conditions(ISerializationContext context, End_Conditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumCall returns EnumCall
	 *
	 * Constraint:
	 *     (en=[Enum|ID] entype=[Symbol|ID])
	 */
	protected void sequence_EnumCall(ISerializationContext context, EnumCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnumCall_En()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnumCall_En()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnumCall_Entype()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnumCall_Entype()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumCallAccess().getEnEnumIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getEnumCall_En(), false));
		feeder.accept(grammarAccess.getEnumCallAccess().getEntypeSymbolIDTerminalRuleCall_3_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getEnumCall_Entype(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Enum
	 *     NonPrimitiveType returns Enum
	 *     Enum returns Enum
	 *     AbstractElement returns Enum
	 *
	 * Constraint:
	 *     (custom='custom'? name=ID enum_fields+=Enum_Field enum_fields+=Enum_Field*)
	 */
	protected void sequence_Enum(ISerializationContext context, uofa.lbirdsey.castle.casl.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Enum_Field returns Symbol
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Enum_Field(ISerializationContext context, Symbol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSymbol_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSymbol_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnum_FieldAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentFieldReference returns EnvironmentFieldReference
	 *
	 * Constraint:
	 *     (env=[Environment|ID] name=ID assignment=Expression?)
	 */
	protected void sequence_EnvironmentFieldReference(ISerializationContext context, EnvironmentFieldReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentInteractionFeatureCall returns EnvironmentInteractionFeatureCall
	 *
	 * Constraint:
	 *     (env=[Symbol|ID] process=[EnvironmentInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_EnvironmentInteractionFeatureCall(ISerializationContext context, EnvironmentInteractionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentInteraction returns EnvironmentInteraction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         interaction_type=InteractionType 
	 *         trigger_type=InteractionTriggerTypes 
	 *         triggerParam=InteractionTriggerParameter? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_EnvironmentInteraction(ISerializationContext context, EnvironmentInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentInteractions returns EnvironmentInteractions
	 *
	 * Constraint:
	 *     interactions+=EnvironmentInteraction*
	 */
	protected void sequence_EnvironmentInteractions(ISerializationContext context, EnvironmentInteractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Environment_Call returns Environment_Call
	 *
	 * Constraint:
	 *     (env=[Environment|ID] qnc=QualifiedNameCall?)
	 */
	protected void sequence_Environment_Call(ISerializationContext context, Environment_Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Environment
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         desc=STRING 
	 *         env_attributes=Environment_Rules 
	 *         env_parameters=Parameters 
	 *         env_functions=Functions 
	 *         env_behaviors=Behaviors 
	 *         env_interactions=EnvironmentInteractions 
	 *         env_adaptation=AdaptiveProcesses 
	 *         env_subSystems=SubSystems 
	 *         env_groupinteractions=EGInteractions
	 *     )
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_attributes()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_attributes()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_parameters()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_parameters()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_functions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_functions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_behaviors()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_behaviors()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_interactions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_interactions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_adaptation()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_adaptation()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_subSystems()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_subSystems()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_groupinteractions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Env_groupinteractions()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironmentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEnvironmentAccess().getDescSTRINGTerminalRuleCall_5_0(), semanticObject.getDesc());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_attributesEnvironment_RulesParserRuleCall_7_0(), semanticObject.getEnv_attributes());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_parametersParametersParserRuleCall_8_0(), semanticObject.getEnv_parameters());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_functionsFunctionsParserRuleCall_9_0(), semanticObject.getEnv_functions());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_behaviorsBehaviorsParserRuleCall_10_0(), semanticObject.getEnv_behaviors());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_interactionsEnvironmentInteractionsParserRuleCall_11_0(), semanticObject.getEnv_interactions());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_adaptationAdaptiveProcessesParserRuleCall_12_0(), semanticObject.getEnv_adaptation());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_subSystemsSubSystemsParserRuleCall_13_0(), semanticObject.getEnv_subSystems());
		feeder.accept(grammarAccess.getEnvironmentAccess().getEnv_groupinteractionsEGInteractionsParserRuleCall_14_0(), semanticObject.getEnv_groupinteractions());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Environment_Rules returns Environment_Rules
	 *
	 * Constraint:
	 *     (env_def=Environment_Type env_attributes=Environment_Attribute layout_type=LayoutType)
	 */
	protected void sequence_Environment_Rules(ISerializationContext context, Environment_Rules semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Env_def()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Env_def()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Env_attributes()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Env_attributes()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Layout_type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Rules_Layout_type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironment_RulesAccess().getEnv_defEnvironment_TypeEnumRuleCall_3_0(), semanticObject.getEnv_def());
		feeder.accept(grammarAccess.getEnvironment_RulesAccess().getEnv_attributesEnvironment_AttributeEnumRuleCall_5_0(), semanticObject.getEnv_attributes());
		feeder.accept(grammarAccess.getEnvironment_RulesAccess().getLayout_typeLayoutTypeEnumRuleCall_7_0(), semanticObject.getLayout_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Environment_Type_Name returns Environment_Type_Name
	 *
	 * Constraint:
	 *     environment_type_name=QualifiedName
	 */
	protected void sequence_Environment_Type_Name(ISerializationContext context, Environment_Type_Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Type_Name_Environment_type_name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEnvironment_Type_Name_Environment_type_name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironment_Type_NameAccess().getEnvironment_type_nameQualifiedNameParserRuleCall_1_0(), semanticObject.getEnvironment_type_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Environment_Types returns Environment_Types
	 *
	 * Constraint:
	 *     (environment_types+=Environment_Type_Name environment_types+=Environment_Type_Name*)
	 */
	protected void sequence_Environment_Types(ISerializationContext context, Environment_Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equals
	 *     BooleanExpression returns Equals
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Equals
	 *     Equals returns Equals
	 *     Equals.Equals_1_0_0 returns Equals
	 *     Comparison returns Equals
	 *     Comparison.Comparison_1_0_0 returns Equals
	 *     Subtraction returns Equals
	 *     Subtraction.Subtraction_1_0 returns Equals
	 *     Addition returns Equals
	 *     Addition.Addition_1_0 returns Equals
	 *     Multiplication returns Equals
	 *     Multiplication.Multiplication_1_0_0_0 returns Equals
	 *     Multiplication.Div_1_0_1_0 returns Equals
	 *     Prefixed returns Equals
	 *
	 * Constraint:
	 *     (left=Equals_Equals_1_0_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalInteractionFeatureCall returns ExternalInteractionFeatureCall
	 *
	 * Constraint:
	 *     (process=[GroupExternalInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_ExternalInteractionFeatureCall(ISerializationContext context, ExternalInteractionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureCall returns FeatureCall
	 *
	 * Constraint:
	 *     (
	 *         fc=AdaptiveProcessFeatureCall | 
	 *         fc=AgentInteractionFeatureCall | 
	 *         fc=EnvironmentInteractionFeatureCall | 
	 *         fc=InteractionFeatureCall | 
	 *         fc=FunctionFeatureCall | 
	 *         fc=BehaviorFeatureCall | 
	 *         fc=GroupExternalInteractionFeatureCall | 
	 *         fc=GroupSelfInternalInteractionsFeatureCall | 
	 *         fc=GroupInternalInteractionsFeatureCall | 
	 *         fc=ExternalInteractionFeatureCall
	 *     )
	 */
	protected void sequence_FeatureCall(ISerializationContext context, FeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] name=ID? val=AbstractElement?)
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (declaration=DataTypeDeclaration | agentFieldRef=AgentFieldReference | envFieldRef=EnvironmentFieldReference | grpFieldRef=GroupFieldReference)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns FloatType
	 *     PrimitiveType returns FloatType
	 *     FloatType returns FloatType
	 *
	 * Constraint:
	 *     name='float'
	 */
	protected void sequence_FloatType(ISerializationContext context, FloatType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatTypeAccess().getNameFloatKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForEachAccess returns Symbol
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ForEachAccess(ISerializationContext context, Symbol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSymbol_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSymbol_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachAccessAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ForEachLoop
	 *     ForEachLoop returns ForEachLoop
	 *     BooleanExpression returns ForEachLoop
	 *     BooleanExpression.BooleanExpression_1_0_0 returns ForEachLoop
	 *     Equals returns ForEachLoop
	 *     Equals.Equals_1_0_0 returns ForEachLoop
	 *     Comparison returns ForEachLoop
	 *     Comparison.Comparison_1_0_0 returns ForEachLoop
	 *     Subtraction returns ForEachLoop
	 *     Subtraction.Subtraction_1_0 returns ForEachLoop
	 *     Addition returns ForEachLoop
	 *     Addition.Addition_1_0 returns ForEachLoop
	 *     Multiplication returns ForEachLoop
	 *     Multiplication.Multiplication_1_0_0_0 returns ForEachLoop
	 *     Multiplication.Div_1_0_1_0 returns ForEachLoop
	 *     Prefixed returns ForEachLoop
	 *
	 * Constraint:
	 *     (
	 *         ty=QualifiedName 
	 *         item=ForEachAccess 
	 *         list=Expression 
	 *         (body+=Expression | body+=SelfAssignedFormula | body+=Formula | body+=Field | body+=Raw_Java_Block)+
	 *     )
	 */
	protected void sequence_ForEachLoop(ISerializationContext context, ForEachLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ForLoop
	 *     ForLoop returns ForLoop
	 *     BooleanExpression returns ForLoop
	 *     BooleanExpression.BooleanExpression_1_0_0 returns ForLoop
	 *     Equals returns ForLoop
	 *     Equals.Equals_1_0_0 returns ForLoop
	 *     Comparison returns ForLoop
	 *     Comparison.Comparison_1_0_0 returns ForLoop
	 *     Subtraction returns ForLoop
	 *     Subtraction.Subtraction_1_0 returns ForLoop
	 *     Addition returns ForLoop
	 *     Addition.Addition_1_0 returns ForLoop
	 *     Multiplication returns ForLoop
	 *     Multiplication.Multiplication_1_0_0_0 returns ForLoop
	 *     Multiplication.Div_1_0_1_0 returns ForLoop
	 *     Prefixed returns ForLoop
	 *
	 * Constraint:
	 *     (
	 *         (init=Expression | init=Formula | init=Field | init=SelfAssignedFormula) 
	 *         condition=Expression 
	 *         (shifter=Expression | shifter=Formula) 
	 *         (body+=Expression | body+=SelfAssignedFormula | body+=Formula | body+=Field | body+=Raw_Java_Block)+
	 *     )
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Formula
	 *
	 * Constraint:
	 *     (sym=[Symbol|ID] objField=[Symbol|ID]? expr=Expression)
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (obj=[Symbol|ID] ((func=[Function|ID] inputs+=Expression? inputs+=Expression*) | (fields+=[Symbol|ID] fields+=[Symbol|ID]*)))
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionFeatureCall returns FunctionFeatureCall
	 *
	 * Constraint:
	 *     (process=[Function|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_FunctionFeatureCall(ISerializationContext context, FunctionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionParameter returns FunctionParameter
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             type=PrimitiveType | 
	 *             agent=[Agent|ID] | 
	 *             env=[Environment|ID] | 
	 *             (
	 *                 obj=[NonPrimitiveType|ID] 
	 *                 (useObj=[NonPrimitiveType|ID] | useType=PrimitiveType | useGroup=[Group|ID] | useAgent=[Agent|ID] | useEnv=[Environment|ID])?
	 *             ) | 
	 *             grp=[Group|ID]
	 *         ) 
	 *         name=ID
	 *     )
	 */
	protected void sequence_FunctionParameter(ISerializationContext context, FunctionParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         functionParameters+=FunctionParameter? 
	 *         functionParameters+=FunctionParameter* 
	 *         returnType=FunctionParameter? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula | body+=Raw_Java_Block)*
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Functions returns Functions
	 *
	 * Constraint:
	 *     functions+=Function*
	 */
	protected void sequence_Functions(ISerializationContext context, Functions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupExternalInteractionFeatureCall returns GroupExternalInteractionFeatureCall
	 *
	 * Constraint:
	 *     (grp=[Symbol|ID] process=[GroupExternalInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_GroupExternalInteractionFeatureCall(ISerializationContext context, GroupExternalInteractionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns GroupExternalInteraction
	 *     GroupExternalInteraction returns GroupExternalInteraction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         transmissionPhase=Transmission_Phase 
	 *         transmissionContents=Transmission_Contents 
	 *         transmissionRepeat=Transmission_Repeat 
	 *         reaction_time_parm=Expression? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_GroupExternalInteraction(ISerializationContext context, GroupExternalInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupExternalInteractions returns GroupExternalInteractions
	 *
	 * Constraint:
	 *     external_interactions+=GroupExternalInteraction*
	 */
	protected void sequence_GroupExternalInteractions(ISerializationContext context, GroupExternalInteractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupFieldReference returns GroupFieldReference
	 *
	 * Constraint:
	 *     (grp=[Group|ID] name=ID assignment=Expression?)
	 */
	protected void sequence_GroupFieldReference(ISerializationContext context, GroupFieldReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns GroupInternalInteraction
	 *     GroupInternalInteraction returns GroupInternalInteraction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         interaction_type=InteractionType 
	 *         trigger_type=InteractionTriggerTypes 
	 *         triggerParam=InteractionTriggerParameter? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_GroupInternalInteraction(ISerializationContext context, GroupInternalInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupInternalInteractionsFeatureCall returns GroupInternalInteractionsFeatureCall
	 *
	 * Constraint:
	 *     (grp=[Symbol|ID] process=[GroupInternalInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_GroupInternalInteractionsFeatureCall(ISerializationContext context, GroupInternalInteractionsFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupInternalInteractions returns GroupInternalInteractions
	 *
	 * Constraint:
	 *     internal_interactions+=GroupInternalInteraction*
	 */
	protected void sequence_GroupInternalInteractions(ISerializationContext context, GroupInternalInteractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupSelfInternalInteractionsFeatureCall returns GroupSelfInternalInteractionsFeatureCall
	 *
	 * Constraint:
	 *     (process=[GroupInternalInteraction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_GroupSelfInternalInteractionsFeatureCall(ISerializationContext context, GroupSelfInternalInteractionsFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Group_Call returns Group_Call
	 *
	 * Constraint:
	 *     (grp=[Group|ID] qnc=QualifiedNameCall?)
	 */
	protected void sequence_Group_Call(ISerializationContext context, Group_Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Group
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         desc=STRING 
	 *         group_rules=Group_Rules 
	 *         group_parameters=Parameters 
	 *         group_functions=Functions 
	 *         group_behaviors=Behaviors 
	 *         group_external_interactions=GroupExternalInteractions 
	 *         group_internal_interactions=GroupInternalInteractions
	 *     )
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Name()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getEntity_Desc()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_rules()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_rules()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_parameters()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_parameters()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_functions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_functions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_behaviors()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_behaviors()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_external_interactions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_external_interactions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_internal_interactions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Group_internal_interactions()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGroupAccess().getDescSTRINGTerminalRuleCall_5_0(), semanticObject.getDesc());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_rulesGroup_RulesParserRuleCall_7_0(), semanticObject.getGroup_rules());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_parametersParametersParserRuleCall_8_0(), semanticObject.getGroup_parameters());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_functionsFunctionsParserRuleCall_9_0(), semanticObject.getGroup_functions());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_behaviorsBehaviorsParserRuleCall_10_0(), semanticObject.getGroup_behaviors());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_external_interactionsGroupExternalInteractionsParserRuleCall_11_0(), semanticObject.getGroup_external_interactions());
		feeder.accept(grammarAccess.getGroupAccess().getGroup_internal_interactionsGroupInternalInteractionsParserRuleCall_12_0(), semanticObject.getGroup_internal_interactions());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Group_Rules returns Group_Rules
	 *
	 * Constraint:
	 *     layout_type=LayoutType
	 */
	protected void sequence_Group_Rules(ISerializationContext context, Group_Rules semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Rules_Layout_type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Rules_Layout_type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroup_RulesAccess().getLayout_typeLayoutTypeEnumRuleCall_4_0(), semanticObject.getLayout_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Group_Type_Name returns Group_Type_Name
	 *
	 * Constraint:
	 *     group_type_name=QualifiedName
	 */
	protected void sequence_Group_Type_Name(ISerializationContext context, Group_Type_Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getGroup_Type_Name_Group_type_name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getGroup_Type_Name_Group_type_name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroup_Type_NameAccess().getGroup_type_nameQualifiedNameParserRuleCall_1_0(), semanticObject.getGroup_type_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Group_Types returns Group_Types
	 *
	 * Constraint:
	 *     (group_types+=Group_Type_Name? group_types+=Group_Type_Name*)
	 */
	protected void sequence_Group_Types(ISerializationContext context, Group_Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfStatement
	 *     IfStatement returns IfStatement
	 *     BooleanExpression returns IfStatement
	 *     BooleanExpression.BooleanExpression_1_0_0 returns IfStatement
	 *     Equals returns IfStatement
	 *     Equals.Equals_1_0_0 returns IfStatement
	 *     Comparison returns IfStatement
	 *     Comparison.Comparison_1_0_0 returns IfStatement
	 *     Subtraction returns IfStatement
	 *     Subtraction.Subtraction_1_0 returns IfStatement
	 *     Addition returns IfStatement
	 *     Addition.Addition_1_0 returns IfStatement
	 *     Multiplication returns IfStatement
	 *     Multiplication.Multiplication_1_0_0_0 returns IfStatement
	 *     Multiplication.Div_1_0_1_0 returns IfStatement
	 *     Prefixed returns IfStatement
	 *
	 * Constraint:
	 *     (
	 *         condition=Expression 
	 *         (then+=Expression | then+=SelfAssignedFormula | then+=Formula | then+=Field)+ 
	 *         elseifexpr+=ElseIfExpr* 
	 *         elseexp+=Expression? 
	 *         ((elseexp+=Formula | elseexp+=SelfAssignedFormula | elseexp+=Field)? elseexp+=Expression?)*
	 *     )
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getImport_ImportedNamespace()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getImport_ImportedNamespace()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntType
	 *     PrimitiveType returns IntType
	 *     IntType returns IntType
	 *
	 * Constraint:
	 *     name='int'
	 */
	protected void sequence_IntType(ISerializationContext context, IntType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntTypeAccess().getNameIntKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InteractionFeatureCall returns InteractionFeatureCall
	 *
	 * Constraint:
	 *     (process=[Interaction|ID] inputs+=Expression? inputs+=Expression*)
	 */
	protected void sequence_InteractionFeatureCall(ISerializationContext context, InteractionFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InteractionTriggerParameter returns InteractionTriggerParameter
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_InteractionTriggerParameter(ISerializationContext context, InteractionTriggerParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getInteractionTriggerParameter_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getInteractionTriggerParameter_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteractionTriggerParameterAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns Interaction
	 *     Interaction returns Interaction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         interaction_type=InteractionType 
	 *         trigger_type=InteractionTriggerTypes 
	 *         triggerParam=InteractionTriggerParameter? 
	 *         (functionParameters+=FunctionParameter functionParameters+=FunctionParameter*)? 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interactions returns Interactions
	 *
	 * Constraint:
	 *     interactions+=Interaction*
	 */
	protected void sequence_Interactions(ISerializationContext context, Interactions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     BooleanExpression returns Div
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Div
	 *     Equals returns Div
	 *     Equals.Equals_1_0_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0_0 returns Div
	 *     Subtraction returns Div
	 *     Subtraction.Subtraction_1_0 returns Div
	 *     Addition returns Div
	 *     Addition.Addition_1_0 returns Div
	 *     Multiplication returns Div
	 *     Multiplication.Multiplication_1_0_0_0 returns Div
	 *     Multiplication.Div_1_0_1_0 returns Div
	 *     Prefixed returns Div
	 *
	 * Constraint:
	 *     (left=Multiplication_Div_1_0_1_0 op='/' right=Prefixed)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getDiv_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getDiv_Left()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getDiv_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getDiv_Op()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getDiv_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getDiv_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getOpSolidusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrefixedParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiplication
	 *     BooleanExpression returns Multiplication
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Multiplication
	 *     Equals returns Multiplication
	 *     Equals.Equals_1_0_0 returns Multiplication
	 *     Comparison returns Multiplication
	 *     Comparison.Comparison_1_0_0 returns Multiplication
	 *     Subtraction returns Multiplication
	 *     Subtraction.Subtraction_1_0 returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0_0_0 returns Multiplication
	 *     Multiplication.Div_1_0_1_0 returns Multiplication
	 *     Prefixed returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0_0_0 op='*' right=Prefixed)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Left()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Op()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getMultiplication_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getOpAsteriskKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrefixedParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns NullType
	 *     PrimitiveType returns NullType
	 *     NullType returns NullType
	 *
	 * Constraint:
	 *     name='null'
	 */
	protected void sequence_NullType(ISerializationContext context, NullType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullTypeAccess().getNameNullKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Object
	 *     NonPrimitiveType returns Object
	 *     Object returns Object
	 *     AbstractElement returns Object
	 *
	 * Constraint:
	 *     (custom='custom'? name=ID useType=[Object|ID]? (fields+=Field | fields+=Function)*)
	 */
	protected void sequence_Object(ISerializationContext context, uofa.lbirdsey.castle.casl.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=AbstractElement*)
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     (fields+=Field | fields+=Concern)*
	 */
	protected void sequence_Parameters(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticSigned
	 *     BooleanExpression returns ArithmeticSigned
	 *     BooleanExpression.BooleanExpression_1_0_0 returns ArithmeticSigned
	 *     Equals returns ArithmeticSigned
	 *     Equals.Equals_1_0_0 returns ArithmeticSigned
	 *     Comparison returns ArithmeticSigned
	 *     Comparison.Comparison_1_0_0 returns ArithmeticSigned
	 *     Subtraction returns ArithmeticSigned
	 *     Subtraction.Subtraction_1_0 returns ArithmeticSigned
	 *     Addition returns ArithmeticSigned
	 *     Addition.Addition_1_0 returns ArithmeticSigned
	 *     Multiplication returns ArithmeticSigned
	 *     Multiplication.Multiplication_1_0_0_0 returns ArithmeticSigned
	 *     Multiplication.Div_1_0_1_0 returns ArithmeticSigned
	 *     Prefixed returns ArithmeticSigned
	 *
	 * Constraint:
	 *     expression=Prefixed
	 */
	protected void sequence_Prefixed(ISerializationContext context, ArithmeticSigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getArithmeticSigned_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getArithmeticSigned_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionPrefixedParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanNegation
	 *     BooleanExpression returns BooleanNegation
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanNegation
	 *     Equals returns BooleanNegation
	 *     Equals.Equals_1_0_0 returns BooleanNegation
	 *     Comparison returns BooleanNegation
	 *     Comparison.Comparison_1_0_0 returns BooleanNegation
	 *     Subtraction returns BooleanNegation
	 *     Subtraction.Subtraction_1_0 returns BooleanNegation
	 *     Addition returns BooleanNegation
	 *     Addition.Addition_1_0 returns BooleanNegation
	 *     Multiplication returns BooleanNegation
	 *     Multiplication.Multiplication_1_0_0_0 returns BooleanNegation
	 *     Multiplication.Div_1_0_1_0 returns BooleanNegation
	 *     Prefixed returns BooleanNegation
	 *
	 * Constraint:
	 *     expression=Prefixed
	 */
	protected void sequence_Prefixed(ISerializationContext context, BooleanNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getBooleanNegation_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getBooleanNegation_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionPrefixedParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Raw_Java_Block returns Raw_Java_Block
	 *
	 * Constraint:
	 *     (name=ID rawStatements+=Raw_Java*)
	 */
	protected void sequence_Raw_Java_Block(ISerializationContext context, Raw_Java_Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelfAssignedFormula returns SelfAssignedFormula
	 *
	 * Constraint:
	 *     (ref=[Symbol|ID] objField=[Symbol|ID]? expr=Expression)
	 */
	protected void sequence_SelfAssignedFormula(ISerializationContext context, SelfAssignedFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelfCall returns SelfCall
	 *
	 * Constraint:
	 *     (ref=[Symbol|ID] | fc=FunctionCall | fec=FeatureCall)?
	 */
	protected void sequence_SelfCall(ISerializationContext context, SelfCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State_Block_Refs returns State_Block_Refs
	 *
	 * Constraint:
	 *     ref=[Symbol|ID]
	 */
	protected void sequence_State_Block_Refs(ISerializationContext context, State_Block_Refs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getState_Block_Refs_Ref()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getState_Block_Refs_Ref()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getState_Block_RefsAccess().getRefSymbolIDTerminalRuleCall_0_1(), semanticObject.eGet(CaslPackage.eINSTANCE.getState_Block_Refs_Ref(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns StringType
	 *     PrimitiveType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     name='string'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getNameStringKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Feature returns SubSystem
	 *     SubSystem returns SubSystem
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         subsystem_type=SubSystemType 
	 *         functionParameters+=FunctionParameter* 
	 *         (body+=Field | body+=Expression | body+=Formula | body+=SelfAssignedFormula)*
	 *     )
	 */
	protected void sequence_SubSystem(ISerializationContext context, SubSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSystems returns SubSystems
	 *
	 * Constraint:
	 *     (subSystems+=SubSystem* (subAgents+=Agent | subEnvs+=Environment)*)
	 */
	protected void sequence_SubSystems(ISerializationContext context, SubSystems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Subtraction
	 *     BooleanExpression returns Subtraction
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Subtraction
	 *     Equals returns Subtraction
	 *     Equals.Equals_1_0_0 returns Subtraction
	 *     Comparison returns Subtraction
	 *     Comparison.Comparison_1_0_0 returns Subtraction
	 *     Subtraction returns Subtraction
	 *     Subtraction.Subtraction_1_0 returns Subtraction
	 *     Addition returns Subtraction
	 *     Addition.Addition_1_0 returns Subtraction
	 *     Multiplication returns Subtraction
	 *     Multiplication.Multiplication_1_0_0_0 returns Subtraction
	 *     Multiplication.Div_1_0_1_0 returns Subtraction
	 *     Prefixed returns Subtraction
	 *
	 * Constraint:
	 *     (left=Subtraction_Subtraction_1_0 op='-' right=Addition)
	 */
	protected void sequence_Subtraction(ISerializationContext context, Subtraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Left()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Op()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSubtraction_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtractionAccess().getSubtractionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubtractionAccess().getOpHyphenMinusKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSubtractionAccess().getRightAdditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemCall returns SystemCall
	 *
	 * Constraint:
	 *     call=QualifiedNameCall
	 */
	protected void sequence_SystemCall(ISerializationContext context, SystemCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystemCall_Call()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystemCall_Call()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemCallAccess().getCallQualifiedNameCallParserRuleCall_2_0(), semanticObject.getCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         desc=STRING 
	 *         cas_rules=CAS_Rules 
	 *         system_parameters=Parameters 
	 *         system_functions=Functions 
	 *         agent_types=Agent_Types 
	 *         group_types=Group_Types 
	 *         environment_types=Environment_Types 
	 *         end_conditions=End_Conditions
	 *     )
	 */
	protected void sequence_System(ISerializationContext context, uofa.lbirdsey.castle.casl.System semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Name()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Desc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Desc()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Cas_rules()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Cas_rules()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_System_parameters()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_System_parameters()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_System_functions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_System_functions()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Agent_types()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Agent_types()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Group_types()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Group_types()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_Environment_types()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_Environment_types()));
			if (transientValues.isValueTransient(semanticObject, CaslPackage.eINSTANCE.getSystem_End_conditions()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CaslPackage.eINSTANCE.getSystem_End_conditions()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemAccess().getNameSTRINGTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSystemAccess().getDescSTRINGTerminalRuleCall_6_0(), semanticObject.getDesc());
		feeder.accept(grammarAccess.getSystemAccess().getCas_rulesCAS_RulesParserRuleCall_10_0(), semanticObject.getCas_rules());
		feeder.accept(grammarAccess.getSystemAccess().getSystem_parametersParametersParserRuleCall_12_0(), semanticObject.getSystem_parameters());
		feeder.accept(grammarAccess.getSystemAccess().getSystem_functionsFunctionsParserRuleCall_13_0(), semanticObject.getSystem_functions());
		feeder.accept(grammarAccess.getSystemAccess().getAgent_typesAgent_TypesParserRuleCall_14_0(), semanticObject.getAgent_types());
		feeder.accept(grammarAccess.getSystemAccess().getGroup_typesGroup_TypesParserRuleCall_15_0(), semanticObject.getGroup_types());
		feeder.accept(grammarAccess.getSystemAccess().getEnvironment_typesEnvironment_TypesParserRuleCall_16_0(), semanticObject.getEnvironment_types());
		feeder.accept(grammarAccess.getSystemAccess().getEnd_conditionsEnd_ConditionsParserRuleCall_17_0(), semanticObject.getEnd_conditions());
		feeder.finish();
	}
	
	
}
